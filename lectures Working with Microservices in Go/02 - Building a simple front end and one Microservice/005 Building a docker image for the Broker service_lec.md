## Лекция

Теперь у нас есть функциональный брокер микросервис, и следующий шаг — разместить его в Docker-образе и запустить. Существует несколько способов сделать это, и я покажу два из них. Первый способ — это многоэтапная сборка с использованием сертифицированного Go Docker-образа. Второй способ значительно быстрее, но начнем с многоэтапной сборки.

### Docker Compose и структура проекта

Первое, что я сделаю, это создам файл Docker Compose, который будет запускать все мои микросервисы. Одна из неприятных вещей в Visual Studio Code — это то, что в рабочем пространстве можно добавлять только папки, но не файлы. Поэтому я вернусь к файловому менеджеру и создам новую папку там, где находятся мои папки с фронтендом и брокер-сервисом. Я назову эту папку "project" и добавлю её в рабочее пространство Visual Studio Code. Внутри этой папки я размещу файл Docker Compose.

### Создание Dockerfile для брокер-сервиса

Теперь откроем папку `broker-service` и создадим в ней новый файл, назвав его `broker-service.dockerfile`. Этот Dockerfile будет указывать Docker Compose, как собрать образ.

#### Содержимое broker-service.dockerfile

```dockerfile
# базовый go-образ
FROM golang:1.22-alpine as builder

RUN mkdir /app

COPY . /app

WORKDIR /app

RUN CGO_ENABLED=0 go build -o brokerApp ./cmd/api 

RUN chmod +x /app/brokerApp 

# создание маленького Docker-образа
FROM alpine:latest

RUN mkdir /app

COPY --from=builder /app/brokerApp /app

CMD [ "/app/brokerApp" ]
```

##### Пояснения к строкам в Dockerfile

1. `FROM golang:1.22-alpine as builder`
   - **FROM**: указывает базовый образ, с которого начинается сборка. 
   - **golang:1.22-alpine**: образ Go версии 1.22 на базе Alpine Linux, легковесной версии Linux.
   - **as builder**: задает алиас (псевдоним) для этого этапа сборки.

2. `RUN mkdir /app`
   - **RUN**: выполняет команду внутри образа.
   - **mkdir /app**: создает директорию `/app`.

3. `COPY . /app`
   - **COPY**: копирует файлы и директории из текущего контекста сборки (рабочая директория) в образ.
   - **. /app**: копирует все файлы из текущей директории в `/app` внутри образа.

4. `WORKDIR /app`
   - **WORKDIR**: устанавливает рабочую директорию для следующих инструкций RUN, CMD, ENTRYPOINT, COPY и ADD.

5. `RUN CGO_ENABLED=0 go build -o brokerApp ./cmd/api`
   - **CGO_ENABLED=0**: устанавливает переменную окружения для отключения использования C-библиотек.
   - **go build -o brokerApp ./cmd/api**: компилирует Go-код в исполняемый файл `brokerApp`.

6. `RUN chmod +x /app/brokerApp`
   - **chmod +x**: делает файл `brokerApp` исполняемым. Это необходимо, чтобы контейнер мог запускать приложение.

7. `FROM alpine:latest`
   - **FROM**: начинает новый этап сборки с использованием минимального образа Alpine Linux.

8. `RUN mkdir /app`
   - Создает директорию `/app` в новом образе.

9. `COPY --from=builder /app/brokerApp /app`
   - **COPY --from=builder**: копирует файл `brokerApp` из предыдущего этапа сборки (`builder`) в новую директорию `/app`.

10. `CMD [ "/app/brokerApp" ]`
    - **CMD**: указывает команду, которая будет выполнена при запуске контейнера. В данном случае это запуск исполняемого файла `brokerApp`.

### Многоэтапная сборка и её преимущества

Многоэтапная сборка позволяет уменьшить размер конечного Docker-образа, так как в финальном образе остаются только необходимые файлы и зависимости, а инструменты сборки исключаются. Это делает образы более легковесными и безопасными.

### Создание файла Docker Compose

Теперь создадим новый файл в папке проекта и назовем его `docker-compose.yml`. Этот файл описывает, как запускать наши микросервисы.

#### Содержимое docker-compose.yml

```yaml
version: '3'

services:

  broker-service:
    build:
      context: ./../broker-service
      dockerfile: ./../broker-service/broker-service.dockerfile/
    restart: always
    ports:
      - "8080:80"
    deploy:
      mode: replicated
      replicas: 1
```

##### Пояснения к строкам в Docker Compose

1. `version: '3'`
   - Указывает версию Docker Compose, которая должна быть использована. Версия 3 выбрана потому, что она предоставляет поддерживаемые и стабильные функции для многоконтейнерных приложений.

2. `services`
   - Определяет список всех сервисов (контейнеров), которые будут запущены.

3. `broker-service`
   - Имя сервиса, который мы настраиваем.

4. `build`
   - Параметры сборки образа для сервиса.

5. `context: ./../broker-service`
   - Контекст сборки, указывает путь к исходным файлам сервиса.

6. `dockerfile: ./../broker-service/broker-service.dockerfile/`
   - Указывает путь к Dockerfile, который будет использоваться для сборки образа.

7. `restart: always`
   - Настройка перезапуска контейнера в случае его падения.

8. `ports`
   - Отображение портов: в данном случае порт 8080 на хосте отображается на порт 80 в контейнере.

9. `deploy`
   - Настройки развертывания.

10. `mode: replicated`
    - Режим репликации, указывает, что сервис будет реплицироваться.

11. `replicas: 1`
    - Количество реплик (экземпляров) сервиса. В данном случае одна реплика, так как у нас один контейнер.

### Версия Docker Compose

Хотя в терминале отображается версия Docker Compose 2.11.2, используется версия файла `docker-compose.yml` версии 3. Это связано с тем, что версии файлов Docker Compose (например, '2', '3') не обязательно должны совпадать с версией установленного инструмента Docker Compose. Версия файла определяет набор функций и синтаксических возможностей, которые могут быть использованы при описании конфигурации контейнеров.

### Запуск контейнеров

Чтобы запустить наши контейнеры, нужно открыть терминал, перейти в папку проекта и выполнить команду:

```sh
docker-compose up -d
```

Команда запускает все контейнеры в фоновом режиме. После этого можно проверить состояние контейнеров в Docker Dashboard и убедиться, что всё работает корректно.

### Подключение фронтенда

Теперь, когда брокер-сервис запущен, мы можем перейти к фронтенду и добавить логику в HTML-шаблон, чтобы убедиться, что фронтенд может взаимодействовать с брокер-сервисом. Это будет рассмотрено в следующей лекции.

## Объяснение терминов и концепций

### Dockerfile и его назначение

`Dockerfile` — это текстовый файл с инструкциями по созданию Docker-образа. Он описывает шаги, необходимые для сборки образа, такие как установка зависимостей, копирование файлов и выполнение команд. В нашем примере `broker-service.dockerfile` используется для создания Docker-образа брокер-сервиса.

### Расположение `broker-service.dockerfile`

Файл `broker-service.dockerfile` находится в папке `broker-service`, потому что он содержит инструкции по сборке именно этого микросервиса. Это упрощает управление и сборку образов для каждого микросервиса в отдельности.

### Многоэтапная сборка и её преимущества

Многоэтапная сборка позволяет уменьшить размер конечного Docker-образа, так как в финальном образе остаются только необходимые файлы и зависимости, а инструменты сборки исключаются. Это делает образы более легковесными и безопасными.

### Docker Compose и его связь с Dockerfile

`Docker Compose` — это инструмент для определения и запуска многоконтейнерных Docker-приложений. Он использует `docker-compose.yml` для описания конфигурации приложений. В этом файле указываются параметры сборки и запуска контейнеров, включая путь к `Dockerfile`.

### Версия Docker Compose

Выбор версии 3 для файла `docker-compose.yml` обусловлен совместимостью с установленной версией Docker Compose и поддержкой необходимых функций для развертывания и управления микросервисами. Версии файлов Docker Compose, такие как '2' и '3', определяют набор функций и возможностей, которые могут быть использованы, но они не зависят напрямую от версии установленного инструмента Docker Compose.

---

## Основные понятия

#### Контейнеры (Containers)
Контейнеры — это изолированные среды, в которых запускаются приложения. Они позволяют упаковать код и все его зависимости вместе, чтобы приложение могло работать в любом окружении. Контейнеры похожи на виртуальные машины, но они легче, потому что используют общие ресурсы операционной системы, что позволяет им запускаться быстрее и занимать меньше места.

Пример: Представьте контейнер как небольшую коробку, в которой находится всё необходимое для работы приложения: код, библиотеки, настройки. Эту коробку можно легко переместить и запустить на любом компьютере, который поддерживает контейнеры.

#### Образы (Images)
Образы — это шаблоны для создания контейнеров. Они содержат всё, что нужно для запуска приложения: операционную систему, зависимости, настройки и сам код приложения. Образ можно представить как слепок или шаблон, из которого создаются контейнеры.

Пример: Образ можно представить как рецепт для приготовления блюда. Следуя этому рецепту (образу), вы каждый раз сможете приготовить одинаковое блюдо (контейнер).

#### Сборки (Builds)
Сборки — это процесс создания образов. Когда мы собираем образ, мы выполняем определённые шаги, описанные в Dockerfile, чтобы создать конечный образ, который можно будет использовать для создания контейнеров.

Пример: Сборка — это процесс приготовления блюда по рецепту. Вы следуете шаг за шагом инструкциям, чтобы в итоге получить готовое блюдо.

### Этапы создания образа

1. **Написание Dockerfile**
   - Dockerfile — это текстовый файл с инструкциями, которые описывают, как создать образ. В нём указывается базовый образ (например, `FROM ubuntu`), копируются файлы, устанавливаются зависимости и конфигурируется приложение.
   - Пример:
     ```Dockerfile
     FROM golang:1.18
     WORKDIR /app
     COPY . .
     RUN go build -o myapp
     CMD ["./myapp"]
     ```

2. **Сборка образа**
   - Командой `docker build` мы запускаем процесс сборки образа, следуя инструкциям в Dockerfile. Docker создаёт образ пошагово, выполняя каждую инструкцию.
   - Пример:
     ```bash
     docker build -t myapp-image .
     ```
     Здесь `-t` указывает тег (имя) для образа, а `.` означает, что Dockerfile находится в текущей директории.

3. **Запуск контейнера**
   - После сборки образа мы можем создать и запустить контейнер на его основе командой `docker run`.
   - Пример:
     ```bash
     docker run --name myapp-container -p 8080:8080 myapp-image
     ```
     Здесь `--name` задаёт имя контейнеру, а `-p` пробрасывает порт 8080 на хосте в порт 8080 внутри контейнера.

### Основные команды для создания образов

1. **docker build**
   - Команда для сборки образа на основе Dockerfile.
   - Пример:
     ```bash
     docker build -t myapp-image .
     ```

2. **docker run**
   - Команда для создания и запуска контейнера из образа.
   - Пример:
     ```bash
     docker run --name myapp-container -p 8080:8080 myapp-image
     ```

3. **docker ps**
   - Команда для отображения всех запущенных контейнеров.
   - Пример:
     ```bash
     docker ps
     ```

4. **docker images**
   - Команда для отображения всех образов на вашем компьютере.
   - Пример:
     ```bash
     docker images
     ```

5. **docker rm** и **docker rmi**
   - Команды для удаления контейнеров и образов соответственно.
   - Пример:
     ```bash
     docker rm myapp-container
     docker rmi myapp-image
     ```

### Конечный результат

В конце процесса мы получаем:

- **Образ Docker**: Это шаблон, который содержит всё необходимое для запуска приложения.
- **Контейнер Docker**: Это запущенный экземпляр образа, который изолирован и работает независимо от других процессов на системе.

Контейнеры можно легко запускать, останавливать, удалять и переносить на другие машины, обеспечивая консистентность работы приложения в разных средах.