### Лекция: Использование Makefile для автоматизации задач в разработке

#### Введение

Эта лекция предназначена для пользователей Mac и Linux. Пользователи Windows могут пропустить её и перейти к следующей лекции. Мы обсудим, как упростить нашу работу, используя Makefile для автоматизации часто выполняемых задач.

#### Шаг 1: Загрузка и настройка Makefile

В ресурсах курса к этой лекции вы найдете Makefile. Скачайте, распакуйте его и разместите в папке проекта. Убедитесь, что файл называется "Makefile" с заглавной буквы и без расширения. Вот как он выглядит:

#### Обзор Makefile

Makefile содержит следующие строки:

1. Первые две строки определяют переменные:

    - `FRONT_END_BINARY` — для скомпилированной версии фронтенд приложения.
    - `BROKER_BINARY` — для скомпилированной версии микросервиса брокера.

2. Строки 5, 11 и 19 — команды, которые будут выполняться при вызове различных целей Makefile:
    - `make up` — запускает Docker-образы.
    - `make up_build` — останавливает Docker-образы, если они запущены, строит все проекты и запускает Docker Compose.
    - `down` — останавливает Docker Compose.
    - `build_broker` — строит Linux-версию микросервиса брокера.
    - `build_front` — строит фронтенд.
    - `start` — запускает фронтенд.
    - `stop` — останавливает фронтенд.

#### Использование Makefile

Сейчас мы можем выполнять команды из Makefile. Например:

1. Убедимся, что Docker Compose не запущен: `docker-compose down`.
2. Остановим фронтенд, если он запущен: `make stop`.

Теперь мы можем выполнить команду `make up_build`, чтобы построить и запустить наш проект:

```bash
make up_build
```

Это займет некоторое время, так как необходимо скачать и установить необходимые компоненты для Linux Docker-образа и скомпилировать его.

#### Ускорение процесса сборки

Первоначальная сборка заняла примерно 25 секунд. Чтобы сократить время сборки, изменим Dockerfile микросервиса брокера.

**Исходный Dockerfile:**

```Dockerfile
FROM golang:1.22-alpine as builder

RUN mkdir /app

COPY . /app

WORKDIR /app

RUN CGO_ENABLED=0 go build -o brokerApp ./cmd/api

RUN chmod +x /app/brokerApp

FROM alpine:latest

RUN mkdir /app

COPY --from=builder /app/brokerApp /app

CMD [ "/app/brokerApp" ]
```

**Измененный Dockerfile:**

```Dockerfile
FROM alpine:latest

RUN mkdir /app

COPY brokerApp /app

CMD [ "/app/brokerApp" ]
```

Мы удалили первые 14 строк и изменили Dockerfile так, чтобы он просто копировал уже скомпилированный бинарный файл `brokerApp` в образ.

Теперь при повторном выполнении команды `make up_build` процесс сборки будет значительно быстрее.

Давайте разберем строки этого **Dockerfile** по порядку и объясним простыми словами, что делает каждая команда:

### 1. `FROM alpine:latest`

Эта строка указывает, что мы будем использовать базовый образ `alpine` с тегом `latest` для создания нашего Docker-образа.

-   **`FROM`**: Указывает базовый образ, который будет использоваться для сборки нового образа.
-   **`alpine:latest`**: Это легковесный и минималистичный образ операционной системы на базе Linux. `latest` означает, что мы берем самую последнюю версию этого образа.

**Простыми словами:** Мы начинаем с чистого, легковесного Linux-образа.

### 2. `RUN mkdir /app`

Эта команда создает новую директорию `/app` внутри контейнера.

-   **`RUN`**: Выполняет команду внутри контейнера на этапе его сборки.
-   **`mkdir /app`**: Создает директорию `/app`.

**Простыми словами:** Мы создаем папку `/app` внутри контейнера, куда будем помещать наш скомпилированный файл.

### 3. `COPY brokerApp /app`

Эта команда копирует файл `brokerApp` из текущей директории на хосте (компьютера, на котором запускается Docker) в директорию `/app` внутри контейнера.

-   **`COPY`**: Копирует файлы из хост-системы в контейнер.
-   **`brokerApp`**: Имя файла, который мы хотим скопировать.
-   **`/app`**: Путь внутри контейнера, куда будет скопирован файл.

**Простыми словами:** Мы копируем наш скомпилированный файл `brokerApp` в папку `/app` внутри контейнера.

### 4. `CMD [ "/app/brokerApp" ]`

Эта команда указывает, какую программу запустить, когда контейнер стартует.

-   **`CMD`**: Устанавливает команду по умолчанию для выполнения при запуске контейнера.
-   **`[ "/app/brokerApp" ]`**: Указывает путь к исполняемому файлу внутри контейнера, который будет запущен.

**Простыми словами:** Когда контейнер запускается, он будет выполнять наш файл `brokerApp` из папки `/app`.

### Краткое описание Dockerfile

-   **FROM alpine:latest**: Начинаем с чистого, легковесного образа операционной системы Alpine Linux.
-   **RUN mkdir /app**: Создаем директорию `/app` внутри контейнера.
-   **COPY brokerApp /app**: Копируем наш скомпилированный файл `brokerApp` в директорию `/app` внутри контейнера.
-   **CMD [ "/app/brokerApp" ]**: Указываем, что при запуске контейнера должна выполняться программа `brokerApp` из директории `/app`.

Эти команды позволяют нам создать минималистичный Docker-образ, который содержит наш скомпилированный файл и автоматически запускает его при старте контейнера.

### Почему процесс сборки Docker-образа стал быстрее после внесения изменений в Dockerfile.

#### Оригинальная версия Dockerfile

В оригинальной версии Dockerfile происходило следующее:

1. Использовался образ `golang:1.22-alpine`, который включает в себя все необходимое для сборки Go-приложений.
2. В контейнер копировались все исходные файлы проекта.
3. В контейнере выполнялась сборка (`go build`), что занимало время, особенно если проект большой или требует загрузки зависимостей.

#### Измененная версия Dockerfile

В измененной версии Dockerfile мы сделали следующее:

1. Использовали только образ `alpine:latest`, который гораздо легче и не содержит инструментов для сборки Go-приложений.
2. Копировали уже скомпилированный файл `brokerApp` в контейнер.

#### Почему стало быстрее?

1. **Исключение этапа сборки в контейнере**:

    - В оригинальной версии мы копировали весь исходный код и собирали его внутри контейнера, что занимало значительное время.
    - В измененной версии мы собираем бинарный файл `brokerApp` на хост-машине (вашем компьютере) и просто копируем готовый файл в контейнер. Это экономит время, так как сборка происходит один раз на хосте, а не каждый раз внутри контейнера.

2. **Меньший размер образа**:
    - Образ `alpine:latest` гораздо легче по сравнению с `golang:1.22-alpine`, так как не содержит инструментов для разработки.
    - Меньший образ быстрее скачивается и разворачивается, что также экономит время.

#### Процесс сборки

-   **Оригинальная версия**:

    1. Копирование исходного кода.
    2. Установка зависимостей и сборка проекта внутри контейнера.
    3. Создание финального образа.

-   **Измененная версия**:
    1. Копирование уже скомпилированного бинарного файла.
    2. Создание финального образа.

### Кратко, почему увеличилась скорость сборки

Скорость сборки увеличилась за счет исключения этапа сборки кода внутри контейнера и уменьшения размера базового образа. Мы заранее собираем проект на хосте, а в контейнер помещаем уже готовый исполняемый файл. Это позволяет значительно ускорить процесс создания Docker-образа.

#### Итоги

Мы создали и настроили Makefile для автоматизации задач, таких как сборка и запуск Docker-образов. Это позволяет упростить и ускорить работу над проектом, делая процесс разработки более эффективным. В последующих лекциях мы будем расширять Makefile, добавляя новые цели для управления другими микросервисами.

#### Пример Makefile:

```Makefile
FRONT_END_BINARY=frontApp
BROKER_BINARY=brokerApp

## up: starts all containers in the background without forcing build
up:
	@echo "Starting Docker images..."
	docker-compose up -d
	@echo "Docker images started!"

## up_build: stops docker-compose (if running), builds all projects and starts docker compose
up_build: build_broker
	@echo "Stopping docker images (if running...)"
	docker-compose down
	@echo "Building (when required) and starting docker images..."
	docker-compose up --build -d
	@echo "Docker images built and started!"

## down: stop docker compose
down:
	@echo "Stopping docker compose..."
	docker-compose down
	@echo "Done!"

## build_broker: builds the broker binary as a linux executable
build_broker:
	@echo "Building broker binary..."
	cd ../broker-service && env GOOS=linux CGO_ENABLED=0 go build -o ${BROKER_BINARY} ./cmd/api
	@echo "Done!"

## build_front: builds the front end binary
build_front:
	@echo "Building front end binary..."
	cd ../front-end && env CGO_ENABLED=0 go build -o ${FRONT_END_BINARY} ./cmd/web
	@echo "Done!"

## start: starts the front end
start: build_front
	@echo "Starting front end"
	cd ../front-end && ./${FRONT_END_BINARY} &

## stop: stop the front end
stop:
	@echo "Stopping front end..."
	@-pkill -SIGTERM -f "./${FRONT_END_BINARY}"
	@echo "Stopped front end!"
```
