### Создание Вспомогательных Функций для Работа с JSON

В рамках разработки микросервисов часто приходится работать с JSON-данными — читать их и записывать. Для упрощения этих задач удобно создать вспомогательные функции, которые будут отвечать за работу с JSON. Давайте разберем, как это сделать.

#### Создание файла с вспомогательными функциями

1. В каталоге `broker-service/cmd/api` создаем новый файл `helpers.go`.
2. Переносим в него тип данных `jsonResponse`, который определен в файле `handlers.go`.

```go
package main

import (
    "encoding/json"
    "errors"
    "io"
    "net/http"
)

type jsonResponse struct {
    Error   bool   `json:"error"`
    Message string `json:"message"`
    Data    any    `json:"data,omitempty"`
}
```

#### Функция для чтения JSON

Создаем функцию `readJSON`, которая будет читать JSON из HTTP-запроса.

```go
func (app *Config) readJSON(w http.ResponseWriter, r *http.Request, data any) error {
    maxBytes := 1048576 // один мегабайт

    r.Body = http.MaxBytesReader(w, r.Body, int64(maxBytes))

    dec := json.NewDecoder(r.Body)
    err := dec.Decode(data)
    if err != nil {
        return err
    }

    err = dec.Decode(&struct{}{})
    if err != io.EOF {
        return errors.New("тело запроса должно содержать только одно значение JSON")
    }

    return nil
}
```

Эта функция читает JSON из HTTP-запроса.
Она ограничивает размер тела запроса до одного мегабайта и декодирует JSON в предоставленный объект. Также проверяет, чтобы JSON был единственным значением.

-   `func (app *Config) readJSON`: Определяем метод readJSON для типа Config.
-   `w http.ResponseWriter`: Параметр для записи ответа.
-   `r *http.Request`: Параметр для чтения запроса.
-   `data any`: Параметр для хранения декодированных данных.
-   `maxBytes := 1048576`: Ограничение размера тела запроса до одного мегабайта.

-   `r.Body = http.MaxBytesReader(w, r.Body, int64(maxBytes))`: Ограничиваем размер тела запроса до одного мегабайта.
-   `dec := json.NewDecoder(r.Body)`: Создаем новый декодер JSON для тела запроса.
-   `err := dec.Decode(data)`: Декодируем JSON из тела запроса в `data`.
-   `if err != nil`: Если произошла ошибка при декодировании, возвращаем ошибку.

-   `err = dec.Decode(&struct{}{})`: Проверяем, что в теле запроса содержится только одно значение JSON.
-   `if err != io.EOF`: Если обнаружены другие данные после первого значения JSON, возвращаем ошибку.
-   Возвращаем `nil`, если ошибок нет.

---

`&struct{}{}` - `struct{}` означает анонимную структуру без полей, а `&struct{}{}` создаёт указатель на такую структуру. Это часто используется, когда вам нужен указатель на структуру, но сама структура не должна содержать никаких данных.

Этот код пытается декодировать JSON из потока в анонимную структуру. Поскольку анонимная структура не содержит полей, она не сохранит никаких данных из JSON. Это может быть использовано для проверки, что JSON корректен и не содержит данных, кроме, возможно, пустого объекта `{}`. Если JSON содержит данные, которые не могут быть декодированы в пустую структуру (то есть, если JSON не пуст), `Decode` вернёт ошибку. Это может быть использовано для проверки, что тело запроса пустое или содержит только пустой JSON объект.

---

#### Функция для записи JSON

Создаем функцию `writeJSON`, которая будет отправлять JSON-ответ.

```go
func (app *Config) writeJSON(w http.ResponseWriter, status int, data any, headers ...http.Header) error {
    out, err := json.Marshal(data)
    if err != nil {
        return err
    }

    if len(headers) > 0 {
        for key, value := range headers[0] {
            w.Header()[key] = value
        }
    }

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(status)
    _, err = w.Write(out)
    if err != nil {
        return err
    }

    return nil
}
```

Эта функция сериализует данные в JSON и отправляет их с указанным статусом и заголовками, т.е. отправляет JSON-ответ.

-   `func (app *Config) writeJSON`: Определяем метод writeJSON для типа Config.
-   `w http.ResponseWriter`: Параметр для записи ответа.
-   `status int`: Код статуса HTTP.
-   `data any`: Данные для сериализации в JSON.
-   `headers ...http.Header`: Дополнительные заголовки (опционально). Это обозначает, что мы можем передать в функцию любое количество аргументов типа `http.Header`, и они будут собраны в слайс `headers`.

-   `out, err := json.Marshal(data)`: Сериализуем данные в JSON.
-   `if err != nil`: Если произошла ошибка при сериализации, возвращаем ошибку.

-   `if len(headers) > 0`: Проверка длины слайса: Проверяем, что передан хотя бы один набор заголовков
-   `for key, value := range headers[0]`: Поскольку у нас обычно только один набор заголовков, итерируемся по `headers[0]` (нулевой элемент слайса).
    -   `headers[0]` - это первый элемент слайса `headers`. В данном контексте предполагается, что если мы передаем заголовки, то передаем их как один `http.Header`(что является картой `map[string][]string`), и этот `http.Header` находится в нулевом элементе слайса.
    -   Мы итерируемся по `headers[0]`, потому что в данной реализации предполагается, что если заголовки передаются, то они передаются в виде одного элемента, который находится в нулевом индексе слайса `headers`.
-   `w.Header()[key] = value` Установка заголовков: Для каждого ключа `key` и значения `value` из `headers[0]`, устанавливаем заголовок в HTTP-ответе `w`.
    -   `w.Header()` возвращает карту заголовков HTTP-ответа.
    -   `[key]` позволяет установить или получить значение заголовка по его имени (ключу).
    -   `value` - это значение заголовка.

---

Передача слайса здесь может показаться избыточной, особенно если в большинстве случаев предполагается использование только первого элемента. Давай разберем это подробнее.

В Go, когда мы объявляем функцию с переменным числом аргументов, как в этом случае с `headers ...http.Header`, это даёт большую гибкость, позволяя передавать любое количество таких аргументов (в том числе и ноль). Вот почему может быть удобно использовать слайс:

-   **Гибкость**: Можно передать один или несколько наборов заголовков.
-   **Совместимость**: Позволяет избежать ошибок, если вдруг потребуется добавить несколько наборов заголовков (например, для более сложной логики).

Принимать слайс `(headers ...http.Header)` даёт гибкость функции на будущее. В данный момент функция использует только первый элемент, но это не ограничивает возможность расширения функции в будущем, где могут понадобиться несколько наборов заголовков. Это позволяет в будущем легко изменить логику и использовать несколько наборов заголовков, если возникнет такая необходимость.

---

#### Функция для отправки ошибок в формате JSON

Создаем функцию `errorJSON`, которая будет отправлять ошибку в формате JSON.

```go
func (app *Config) errorJSON(w http.ResponseWriter, err error, status ...int) error {
    statusCode := http.StatusBadRequest

    if len(status) > 0 {
        statusCode = status[0]
    }

    var payload jsonResponse
    payload.Error = true
    payload.Message = err.Error()

    return app.writeJSON(w, statusCode, payload)
}
```

Эта функция отправляет ошибку с указанием кода статуса и сообщением об ошибке в формате JSON.

-   `func (app *Config) errorJSON`: Определяем метод `errorJSON` для типа `Config`.
-   `w http.ResponseWriter`: Параметр для записи ответа.
-   `err error`: Ошибка для отправки.
-   `status ...int`: Код статуса HTTP (опционально).

-   `statusCode := http.StatusBadRequest`: Устанавливаем код статуса по умолчанию.

-   `if len(status) > 0`: Проверяем, указан ли код статуса.
-   `statusCode = status[0]`: Если указан, устанавливаем его.

-   `var payload jsonResponse`: Создаем переменную `payload` типа `jsonResponse`.
-   `payload.Error = true`: Устанавливаем флаг ошибки.
-   `payload.Message = err.Error()`: Устанавливаем сообщение об ошибке.

-   `return app.writeJSON(w, statusCode, payload)`: Отправляем ответ с помощью writeJSON.

### Применение вспомогательных функций

Теперь можно упростить код в файле `handlers.go`, используя наши вспомогательные функции.

```go
package main

import (
    "net/http"
)

func (app *Config) Broker(w http.ResponseWriter, r *http.Request) {
    payload := jsonResponse{
        Error:   false,
        Message: "Обращение к брокеру выполнено",
    }

    _ = app.writeJSON(w, http.StatusOK, payload)
}
```

Исправив код, нам уже не нужно отправить JSON-ответ вручную. Теперь, используя наши вспомогательные функции `writeJSON`, `readJSON` и `errorJSON`, код в `handlers.go` становится намного проще и чище.

Теперь, когда нам нужно отправить JSON-ответ, мы просто вызываем `app.writeJSON`. Это не только сокращает количество строк кода, но и делает обработчик более чистым и понятным.

### Как вспомогательные функции упрощают код

**Читаемость и удобство**: Вместо того чтобы писать однотипный код для кодирования JSON, установки заголовков и отправки ответа, мы вызываем одну функцию writeJSON.

**Повторное использование**: Функции `writeJSON`, `readJSON` и `errorJSON` можно использовать в других обработчиках, что избавляет от дублирования кода.

**Уменьшение вероятности ошибок**: При ручном написании однотипного кода можно легко допустить ошибку. Вспомогательные функции позволяют централизовать логику и сократить количество возможных ошибок.

### Основные этапы создания вспомогательных функций

1. **Создание файла helpers.go**: В этом файле будут храниться все вспомогательные функции.
2. **Определение типа данных jsonResponse**: Этот тип данных используется для стандартного формата ответа.
3. **Создание функций readJSON, writeJSON и errorJSON**: Эти функции выполняют основные операции по чтению и записи JSON.
4. **Применение вспомогательных функций в других частях кода**: Используем вспомогательные функции для упрощения обработки запросов и ответов.

### Основные команды для работы с JSON

1. **Чтение JSON**:

    ```go
    err := app.readJSON(w, r, &data)
    if err != nil {
        app.errorJSON(w, err)
        return
    }
    ```

2. **Запись JSON**:

    ```go
    _ = app.writeJSON(w, http.StatusOK, payload)
    ```

3. **Отправка ошибки в формате JSON**:
    ```go
    app.errorJSON(w, errors.New("example error"))
    ```

### Итог

В результате мы получаем набор удобных вспомогательных функций для работы с JSON, которые упрощают обработку HTTP-запросов и ответов. Это позволяет делать код чище и более управляемым.
