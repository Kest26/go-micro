**Заголовок:** Процесс Аутентификации в Микросервисной Архитектуре

### Введение

В предыдущем шаге мы подготовили данные пользователей в базе данных. Теперь давайте перейдем к следующему этапу — реализации процесса аутентификации. Мы создадим отдельный микросервис, который будет обрабатывать POST-запросы с JSON-данными, содержащими имя пользователя и пароль. Этот микросервис проверит полученные данные с теми, что хранятся в базе данных, и вернет соответствующий ответ.

Аутентификация является ключевым аспектом любой системы, особенно в микросервисной архитектуре, где различные сервисы взаимодействуют друг с другом. Она позволяет убедиться, что доступ к ресурсам получают только те пользователи, которые прошли проверку подлинности.

### Подготовка к работе с JSON

Для работы с данными в формате JSON, которые мы будем принимать через POST-запросы, нам нужно воспользоваться уже готовыми вспомогательными функциями. Ранее в брокер-сервисе, который мы создали, был файл `helpers.go`. В этом файле содержатся полезные функции для чтения и записи JSON, которые значительно упрощают работу с этим форматом данных.

Для того чтобы не переписывать код, мы можем просто скопировать этот файл в наш новый микросервис аутентификации. Это также поможет нам поддерживать единообразие в проекте.

**Шаги:**

1. Найдите файл `helpers.go` в папке `CMD API` брокер-сервиса.
2. Скопируйте его и вставьте в соответствующую папку микросервиса аутентификации.

Теперь у нас есть готовые функции для работы с JSON в нашем новом микросервисе.

### Повторное использование кода

Вместо того чтобы копировать и вставлять код в каждый микросервис, можно было бы выделить этот код в отдельный пакет. Такой пакет мог бы включать в себя общие функции, которые могут использоваться в разных микросервисах.

Стоит отметить, что аналогичную операцию нам придется выполнять для многих наших микросервисов. Вполне возможно, что вы захотите вынести эту функциональность в отдельный пакет для повторного использования. В лекционных материалах курса есть ссылка на пример такого пакета, который называется **tsawler/toolbox**. Он включает в себя функции для работы с JSON и генерации случайных строк, которые можно легко импортировать и использовать в ваших микросервисах.

Для установки пакета вы можете использовать команду:

```sh
go get github.com/tsawler/toolbox

```

После установки пакета вы можете создать переменную `tools` типа `toolbox.Tools` и получить доступ ко всем методам этого пакета, включая `readJSON`, `writeJSON`, `errorJSON`, и `генерацию случайных строк`.

Однако, чтобы не усложнять процесс обучения, мы будем использовать метод копирования и вставки в данном курсе. Это также поможет лучше понять, как работает каждый компонент системы.

### Настройка маршрута (route)

Теперь, когда у нас есть функции для работы с JSON, мы можем создать маршрут для обработки POST-запросов на `/authenticate`. Этот маршрут будет связан с функцией-обработчиком, которая будет проверять логин и пароль пользователя.

**Шаги:**

1. Перейдите в файл, где описываются маршруты вашего микросервиса.
2. Добавьте следующий маршрут:

```go
mux.Post("/authenticate", app.Authenticate)
```

Этот маршрут направит все POST-запросы, поступающие на `/authenticate`, к функции `Authenticate`, которую мы создадим далее.

### Создание функции-обработчика аутентификации

Функция `Authenticate` будет отвечать за проверку предоставленных пользователем данных. Она примет JSON-данные из запроса, проверит их с данными в базе данных, и в зависимости от результата вернет ответ о том, прошел ли пользователь аутентификацию.

**Шаги:**

1. Создайте новый файл `handlers.go` в папке `CMD/API` вашего микросервиса.
2. Добавьте следующий код:

```go
func (app *Config) Authenticate(w http.ResponseWriter, r *http.Request) {
    // Определяем структуру для хранения данных из JSON
    var requestPayload struct {
        Email    string `json:"email"`
        Password string `json:"password"`
    }

    // Читаем JSON из запроса и проверяем на ошибки
    err := app.readJSON(w, r, &requestPayload)
    if err != nil {
        app.errorJSON(w, err, http.StatusBadRequest)
        return
    }

    // Ищем пользователя в базе данных по email
    user, err := app.Models.User.GetByEmail(requestPayload.Email)
    if err != nil {
        app.errorJSON(w, errors.New("invalid credentials"), http.StatusUnauthorized)
        return
    }

    // Проверяем правильность пароля
    validPassword, err := user.PasswordMatches(requestPayload.Password)
    if err != nil || !validPassword {
        app.errorJSON(w, errors.New("invalid credentials"), http.StatusUnauthorized)
        return
    }

    // Если аутентификация успешна, возвращаем успех
    payload := jsonResponse{
        Error:   false,
        Message: "Authenticated",
        Data:    user,
    }

    app.writeJSON(w, http.StatusAccepted, payload)
}
```

**Разбор кода:**

1. **Определение структуры данных:** Мы создаем структуру, которая будет хранить данные, ожидаемые в запросе, такие как `email` и `password`. Это позволяет нам четко определить, какие данные мы ждем от клиента.
2. **Чтение и валидация JSON:** Сначала функция `readJSON` пытается прочитать данные из запроса. Если JSON некорректен, функция вернет ошибку.
3. **Поиск пользователя в базе данных:** После успешного чтения JSON, мы пытаемся найти пользователя в базе данных по предоставленному email. Если пользователя с таким email не существует, мы возвращаем сообщение об ошибке.
4. **Проверка пароля:** Если пользователь найден, мы проверяем, совпадает ли предоставленный пароль с тем, что хранится в базе данных. Если пароли не совпадают, мы также возвращаем сообщение об ошибке.
5. **Ответ в случае успеха:** Если и email, и пароль корректны, мы возвращаем сообщение об успешной аутентификации и данные пользователя.

### Заключение

Теперь у нас есть полностью функционирующий микросервис для аутентификации. Он способен принимать запросы с данными пользователя, проверять их и возвращать соответствующий результат. Этот сервис является основой для дальнейшего построения защищенной и масштабируемой микросервисной архитектуры.

Мы также обсудили важность повторного использования кода, указав на то, что можно было бы создать отдельный пакет для общих функций. Однако в рамках этого курса мы продолжили использовать метод копирования и вставки, чтобы сосредоточиться на понимании каждого этапа разработки.

Следующим шагом будет интеграция этого микросервиса с другими сервисами или создание дополнительных функций, таких как выдача JWT-токенов для авторизации пользователей.
