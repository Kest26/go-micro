## Взаимодействие микросервисов через RPC в Go

---

### 1. **Введение: JSON для взаимодействия с пользователем**

На протяжении курса мы рассматривали различные способы взаимодействия между микросервисами. Важно понимать, что когда речь идет о взаимодействии между пользователем и сервером (например, через веб-браузер и брокер), стандартным подходом является использование формата JSON. Это связано с тем, что JSON — это широко используемый и функциональный способ передачи данных между браузером и сервисами.

Пример:

Пользователь отправляет запрос на брокер в формате JSON для аутентификации. Брокер принимает этот запрос, разбирает (unmarshal) данные JSON и отправляет запрос в формате JSON на микросервис аутентификации. После этого микросервис аутентификации обрабатывает данные, возвращает JSON-ответ на брокер, который, в свою очередь, передает результат пользователю.

```go
type AuthRequest struct {
    Username string `json:"username"`
    Password string `json:"password"`
}

jsonData := `{"username":"user1","password":"pass123"}`
var authRequest AuthRequest
json.Unmarshal([]byte(jsonData), &authRequest)
```

### 2. **Взаимодействие микросервисов через JSON**

На данный момент, взаимодействие между микросервисами в большинстве случаев также происходит через обмен JSON. Например, когда пользователь обращается к брокеру для аутентификации, брокер отправляет JSON-запрос на микросервис аутентификации. Это классический сценарий взаимодействия, который работает следующим образом:

1. Пользователь отправляет JSON-запрос на брокер для аутентификации.
2. Брокер разбирает запрос и отправляет JSON-запрос на микросервис аутентификации.
3. Микросервис аутентификации обрабатывает данные и возвращает ответ в формате JSON.
4. Брокер передает ответ пользователю.

Этот процесс хорошо работает в большинстве случаев, так как JSON — удобный и общепринятый формат для обмена данными.

Пример:

```go
authRequest := AuthRequest{
    Username: "user1",
    Password: "pass123",
}

jsonData, _ := json.Marshal(authRequest)
http.Post("http://auth-service/auth", "application/json", bytes.NewBuffer(jsonData))
```

### 3. **Очереди для логирования с использованием RabbitMQ**

Кроме обмена JSON, мы также используем очереди для логирования. Например, когда необходимо записать данные в лог, фронтенд отправляет JSON-запрос на брокер, который помещает его в очередь RabbitMQ. Логер (служба, отвечающая за запись логов) получает данные из очереди, обрабатывает их и записывает в лог.

Этот способ также хорошо себя зарекомендовал и активно используется в наших приложениях.

Пример:

```go
logMessage := LogMessage{
    Event: "user_login",
    Data:  "User user1 logged in",
}

jsonData, _ := json.Marshal(logMessage)
rabbitMQChannel.Publish("", "log_queue", false, false, amqp.Publishing{
    ContentType: "application/json",
    Body:        jsonData,
})
```

### 4. **RPC как альтернатива JSON для взаимодействия между микросервисами**

Однако в данном разделе курса мы рассмотрим другой способ взаимодействия между микросервисами — удалённые вызовы процедур (Remote Procedure Calls, RPC). Важное замечание: при использовании RPC в Go обе стороны — вызывающая и принимающая — должны быть написаны на Go.

Пример:

В текущей архитектуре брокер и логер написаны на Go. Мы можем внедрить взаимодействие через RPC между ними для улучшения производительности и быстроты передачи данных.

RPC работает быстрее, чем разбор и сборка JSON, так как минует процесс маршаллинга и анмаршаллинга данных. Это делает RPC предпочтительным выбором в ситуациях, где важна скорость и производительность.

Пример кода для реализации RPC:

```go
// Определение структуры для данных RPC
type LogMessage struct {
    Event string
    Data  string
}

// Определение метода для логирования
func (l *Logger) LogMessage(args *LogMessage, reply *string) error {
    fmt.Println("Received log:", args.Event, args.Data)
    *reply = "Log received"
    return nil
}

// Настройка RPC-сервера
logger := new(Logger)
rpc.Register(logger)
rpc.HandleHTTP()

listener, err := net.Listen("tcp", ":1234")
if err != nil {
    log.Fatal("Listener error:", err)
}

go http.Serve(listener, nil)
```

### 5. **Ограничения использования RPC**

Следует помнить, что использование RPC возможно только в том случае, если обе стороны взаимодействия — например, брокер и логер — написаны на Go. Если один из сервисов реализован на другом языке, например, на Python или Java, RPC не сработает. Для нашей ситуации, где оба сервиса написаны на Go, это не представляет проблемы.

Использование RPC заметно ускоряет передачу данных по сравнению с JSON, и в данном разделе курса мы реализуем взаимодействие через RPC между брокером и логером.

---

### Заключение

RPC может быть быстрее и эффективнее JSON при взаимодействии микросервисов, особенно если все сервисы написаны на Go. В следующей части курса мы научимся на практике реализовывать взаимодействие между брокером и логером через RPC.


