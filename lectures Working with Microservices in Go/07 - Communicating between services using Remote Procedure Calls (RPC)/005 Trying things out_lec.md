## Взаимодействие микросервисов: пример на основе RPC и переход к gRPC

### 1. Запуск проекта и проверка работоспособности

После завершения всех необходимых настроек, мы можем попробовать запустить наш проект и проверить его работу через интерфейс. Для начала открываем терминал, убеждаемся, что находимся в папке с проектом, и вводим команду `make up_build` для сборки и поднятия Docker-образов. Все успешно собралось, и это хороший знак. Сейчас Docker собирает образы и запускает их. Пока всё идет хорошо.

Теперь, подождем, пока RabbitMQ полностью запустится, но параллельно можно очистить экран и ввести команду `make start`, чтобы запустить фронтенд-приложение. Приложение запустилось, и теперь можно открыть браузер и обновить страницу с фронтендом.

### 2. Проверка базы данных

Прежде чем продолжить, откроем MongoDB Compass и проверим коллекцию логов. Подключаемся к недавним соединениям и находим коллекцию с логами внутри базы данных. Вот пример двух записей, которые мы видим:

```json
{
"\_id": {
"$oid": "66d9bb26987626cb84b8ac6c"
  },
  "name": "authentication",
  "data": "admin@example.com logged in",
  "created_at": {
    "$date": "2024-09-05T14:07:34.065Z"
},
"updated_at": {
"$date": "2024-09-05T14:07:34.065Z"
}
}

{
"\_id": {
"$oid": "66d9bd25987626cb84b8ac6d"
  },
  "name": "event",
  "data": "Some kind of data",
  "created_at": {
    "$date": "2024-09-05T14:16:05.029Z"
},
"updated_at": {
"$date": "2024-09-05T14:16:05.030Z"
}
}
```

На данный момент у нас есть две записи, что соответствует ожидаемому результату. Далее убедимся, что RabbitMQ успешно запущен.

### 3. Подключение RabbitMQ и тестирование логов

Переходим в Docker Dashboard и проверяем сервис брокера сообщений. Логи показывают, что система несколько раз пыталась подключиться к RabbitMQ, но в конечном итоге подключение было успешно установлено:

```log
2024-09-11 09:39:39 Connected to RabbitMQ!
2024-09-11 09:39:39 Starting broker service on port 80
```

Теперь мы готовы протестировать работу логирования. Переходим к фронтенду и нажимаем кнопку **"test log"**. В этот момент будет отправлен запрос, который мы можем увидеть в следующем формате:

**Отправленные данные:**

```json
{
    "action": "log",
    "log": {
        "name": "event",
        "data": "Some kind of data"
    }
}
```

**Полученные данные:**

```json
{
    "error": false,
    "message": "Processed payload via RPC:event"
}
```

Сообщение указывает на успешную обработку данных через RPC. Теперь вернемся в MongoDB Compass и обновим коллекцию логов.

### 4. Проверка результата в MongoDB

После обновления коллекции видим, что новая запись успешно добавлена:

```json
{
    "_id": {
        "$oid": "66e14d5cb64cc3b76f558f62"
    },
    "name": "event",
    "data": "Some kind of data",
    "created_at": {
        "$date": "2024-09-11T07:57:16.556Z"
    },
    "updated_at": {
        "$date": {
            "$numberLong": "-62135596800000"
        }
    }
}
```

Запись добавлена, всё работает так, как и должно. Таким образом, мы настроили ещё один способ взаимодействия между микросервисами — через RPC.

### 5. Особенности RPC

**_RPC (Удалённый Вызов Процедур)_** требует использования Go на обеих сторонах взаимодействия — как на клиенте, так и на сервере. Этот способ взаимодействия достаточно эффективен и значительно быстрее, чем обработка данных в формате JSON. RPC является альтернативным методом взаимодействия между микросервисами, который можно использовать в тех случаях, когда скорость имеет критическое значение.

### 6. Переход к gRPC

Теперь давайте перейдём к третьему методу взаимодействия между микросервисами — gRPC. Он немного сложнее, но более портативен. gRPC поддерживается множеством языков программирования, и благодаря этому вы можете писать микросервисы практически на любом языке. В следующем разделе мы подробнее разберём этот подход и его особенности.
