## Настройка RPC-сервера в микросервисе логирования

---

### 1. **Введение: Реализация RPC на примере логера**

В этой лекции мы на практике реализуем RPC в микросервисе логирования. Начнем с логера, так как после настройки RPC в одном сервисе можно легко воспроизвести этот функционал в других сервисах. К счастью, Go делает процесс настройки RPC-сервера удивительно простым.

Мы создадим новый файл для реализации RPC в микросервисе логирования. Этот файл будет называться `rpc.go` и будет находиться в папке `cmd/api`. Все действия будут происходить в пакете `main`.

### 2. **Создание типов для RPC-сервера и данных**

Первый шаг в настройке RPC — это определение типа для нашего RPC-сервера. В Go для реализации RPC-сервера нужен специальный тип, однако он не требует сложных магических конструкций. Мы просто объявляем тип `RPCServer` как пустую структуру.

Следующим шагом будет создание типа для данных, которые мы будем получать через RPC. Мы назовем этот тип `RPCPayload`, и он будет содержать два поля: `Name` (строка) и `Data` (также строка). Эти поля представляют собой полезную нагрузку, которую сервер будет получать и обрабатывать.

Пример кода:

```go
// Тип RPC-сервера
type RPCServer struct{}

// Тип данных, которые будут передаваться через RPC
type RPCPayload struct {
    Name string
    Data string
}
```

### 3. **Реализация метода RPC**

Теперь, когда мы создали типы, необходимо реализовать метод, который будет доступен для вызова через RPC. Мы создадим метод `LogInfo`, который будет привязан к типу `RPCServer`. Этот метод будет принимать два параметра:

1. `payload` — полезная нагрузка типа `RPCPayload`, содержащая имя и данные для записи в лог.
2. `resp` — указатель на строку, который будет использоваться для отправки ответа клиенту.

Метод должен возвращать ошибку, если что-то пошло не так. Основной задачей метода будет запись данных в MongoDB.

Пример кода:

```go
// Метод LogInfo записывает полезную нагрузку в MongoDB
func (r *RPCServer) LogInfo(payload RPCPayload, resp *string) error {
    collection := client.Database("logs").Collection("logs")
    _, err := collection.InsertOne(context.TODO(), data.LogEntry{
        Name:      payload.Name,
        Data:      payload.Data,
        CreatedAt: time.Now(),
    })
    if err != nil {
        log.Println("error writing to mongo", err)
        return err
    }

    // Отправляем ответ клиенту
    *resp = "Processed payload via RPC: " + payload.Name
    return nil
}
```

В этом методе:

- Мы получаем коллекцию `logs` из MongoDB.
- Создаем новый объект типа `LogEntry`, который содержит имя, данные и время создания.
- Записываем этот объект в базу данных.
- Если произошла ошибка при записи, выводим сообщение об ошибке в лог и возвращаем её.
- Если запись прошла успешно, мы отправляем клиенту сообщение об успешной обработке полезной нагрузки.

### 4. **Обработка ошибок и отправка ответа**

После того как данные успешно записаны в MongoDB, необходимо отправить ответ обратно клиенту. Для этого мы используем указатель на строку `resp`, который передан в метод. Мы изменяем значение переменной, указывая, что полезная нагрузка была успешно обработана. В случае ошибки выводим сообщение об ошибке и возвращаем её.

#### 5. **Заключение: Подготовка к прослушиванию RPC-соединений**

На этом этапе мы реализовали базовый функционал RPC-сервера, который принимает данные и записывает их в лог. Следующим шагом будет настройка нашего логера для прослушивания RPC-соединений. Мы продолжим это в следующей лекции.

---

## Полный код файла `rpc.go`:

```go
package main

import (
	"context"
	"log"
	"log-service/data"
	"time"
)

// RPCServer — это тип для нашего RPC-сервера. Методы с этим типом в качестве получателя доступны для вызова через RPC.
type RPCServer struct{}

// RPCPayload — это тип данных, которые мы получаем через RPC.
type RPCPayload struct {
	Name string
	Data string
}

// LogInfo записывает полученные данные в MongoDB
func (r *RPCServer) LogInfo(payload RPCPayload, resp *string) error {
	collection := client.Database("logs").Collection("logs")
	_, err := collection.InsertOne(context.TODO(), data.LogEntry{
		Name:      payload.Name,
		Data:      payload.Data,
		CreatedAt: time.Now(),
	})
	if err != nil {
		log.Println("error writing to mongo", err)
		return err
	}

	// resp — это сообщение, которое мы отправляем обратно RPC-клиенту
	*resp = "Processed payload via RPC: " + payload.Name
	return nil
}
```
