## Вызов логгера из брокера с использованием RPC

### Введение

Теперь, когда наш RPC-сервер настроен в микросервисе логгера, нам нужно внести изменения в брокер, чтобы иметь возможность вызывать этот сервер. В этом разделе мы изменим наш брокер-сервис так, чтобы он мог отправлять запросы на логгирование через RPC. Изменения будут внесены в файл `handlers.go`, и они будут очень похожи на то, что мы делали в предыдущем разделе с RabbitMQ.

### Обновление метода логгирования в брокере

Начнем с того, что откроем файл `handlers.go`, находящийся в папке `cmd/api` брокера, и внесем изменения в код метода `HandleSubmission`.

В частности, нам нужно изменить вызов функции логирования в операторе `switch`. Вместо того чтобы логгировать через RabbitMQ, мы будем вызывать новую функцию, которая будет логгировать данные через RPC. Важно сохранить старый вызов через RabbitMQ в качестве примера, чтобы он был у нас под рукой.

### Создание функции для логгирования через RPC

Далее в файле мы создадим новую функцию внизу, которая будет отвечать за логгирование через RPC. Функция будет принимать те же параметры, что и старая — `http.ResponseWriter` и структуру `LogPayload`, содержащую данные для логирования.

```go
func (app *Config) logItemViaRPC(w http.ResponseWriter, l LogPayload) {
    // RPC клиент
}
```

Эта функция не возвращает значений, поэтому мы сразу можем приступить к реализации. Первое, что нам нужно сделать, — это создать RPC-клиент. В Go это делается очень просто.

### Создание RPC-клиента

Создадим RPC-клиент и проверим наличие ошибок при его создании. Для этого мы воспользуемся стандартной библиотекой `rpc` и вызовем метод `rpc.Dial`. Мы будем использовать TCP для подключения к микросервису логгера, который находится на порту 5001. Имя микросервиса берем из файла `docker-compose.yml`.

```go
client, err := rpc.Dial("tcp", "logger-service:5001")
if err != nil {
    app.errorJSON(w, err)
    return
}
```

Если при создании клиента возникла ошибка, мы возвращаем JSON-ответ с ошибкой.

### Создание структуры для отправки данных

Затем нужно создать структуру данных, которая точно соответствует той, что ожидает RPC-сервер на стороне логгера. Для этого мы объявляем структуру `RPCPayload` с полями `Name` и `Data`, аналогично тому, как это сделано на сервере.

```go
type RPCPayload struct {
    Name string
    Data string
}
```

Создадим экземпляр этой структуры и заполним его данными из нашего входного `LogPayload`.

```go
rpcPayload := RPCPayload{
    Name: l.Name,
    Data: l.Data,
}
```

### Вызов RPC метода

Теперь, когда у нас есть клиент и данные, мы можем вызвать удаленный метод. Мы воспользуемся методом `client.Call`, чтобы вызвать на сервере метод `LogInfo`, который будет логгировать данные.

```go
var result string
err = client.Call("RPCServer.LogInfo", rpcPayload, &result)
if err != nil {
    app.errorJSON(w, err)
    return
}
```

Здесь мы передаем три параметра: строку с именем метода, который нужно вызвать, наши данные `rpcPayload` и переменную `result`, куда будет записан результат выполнения метода на сервере. Если вызов метода завершился с ошибкой, возвращаем JSON-ответ с этой ошибкой.

### Отправка результата клиенту

Если все прошло успешно, мы формируем ответ и отправляем его пользователю.

```go
payload := jsonResponse{
    Error:   false,
    Message: result,
}

app.writeJSON(w, http.StatusAccepted, payload)
```

### Замена старой функции логгирования

Теперь, когда наша функция для логгирования через RPC готова, мы можем заменить вызов старой функции логгирования через RabbitMQ в `HandleSubmission` на новую функцию.

```go
switch requestPayload.Action {
case "auth":
    app.authenticate(w, requestPayload.Auth)
case "log":
    app.logItemViaRPC(w, requestPayload.Log)
case "mail":
    app.sendMail(w, requestPayload.Mail)
default:
    app.errorJSON(w, errors.New("unknown action"))
}
```

Таким образом, при поступлении запроса с действием `log` будет вызываться наша новая функция, которая отправляет данные через RPC в микросервис логгера.

### Заключение

Теперь мы обновили брокер-сервис для использования RPC при логгировании событий. На следующем этапе мы соберем всё и проверим, как это работает на практике.
