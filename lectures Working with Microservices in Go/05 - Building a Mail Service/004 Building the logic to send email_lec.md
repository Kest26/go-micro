## Реализация логики отправки email в микросервисе

---

### Введение

Итак, у нас уже настроен каркас микросервиса для отправки писем, и теперь нужно приступить к написанию кода, который будет непосредственно генерировать и отправлять email. В папке `mail-service/cmd/api` создадим новый файл под названием `mailer.go`, где будем разрабатывать логику нашего сервиса.

### Создание и описание структур

#### Структура для конфигурации почтового сервера

Первым шагом мы создадим тип, который будет отвечать за настройку почтового сервера и хранение всех необходимых параметров. Этот тип будет называться `Mail` и представлять собой структуру:

```go
type Mail struct {
	Domain      string
	Host        string
	Port        int
	Username    string
	Password    string
	Encryption  string
	FromAddress string
	FromName    string
}
```

Здесь мы храним:

-   **Domain**: домен, с которого будут отправляться письма. Это важно для указания, откуда исходит сообщение.
-   **Host**: адрес почтового сервера, через который будет осуществляться отправка.
-   **Port**: порт, используемый для подключения.
-   **Username и Password**: учетные данные для аутентификации на почтовом сервере.
-   **Encryption**: тип шифрования (например, `TLS` или `SSL`). В процессе разработки можно обойтись без шифрования, но в продакшн среде его необходимо предусмотреть.
-   **FromAddress и FromName**: адрес и имя отправителя по умолчанию. Если при отправке письма эти параметры не указаны, будут использоваться именно эти значения.

Таким образом, структура `Mail` помогает настроить все необходимые параметры для отправки email.

#### Структура для описания email-сообщения

Теперь создадим еще одну структуру, которая будет описывать само письмо, его содержимое и дополнительные параметры:

```go
type Message struct {
	From        string
	FromName    string
	To          string
	Subject     string
	Attachments []string
	Data        any
	DataMap     map[string]any
}
```

Параметры этой структуры включают:

-   **From и FromName**: адрес и имя отправителя письма. Если эти параметры не указаны, используются значения из структуры `Mail`.
-   **To**: адрес получателя.
-   **Subject**: тема письма.
-   **Attachments**: список вложений (пути к файлам).
-   **Data и DataMap**: данные, которые передаются в шаблон письма и используются для генерации содержимого.

Важно учитывать, что в `Attachments` мы добавляем пути к файлам, которые могут быть приложены к письму. А `DataMap` — это карта, куда мы будем складывать все данные, которые необходимо передать в шаблон.

### Реализация функции отправки email

Теперь создадим метод `SendSMTPMessage` для структуры `Mail`, который будет управлять процессом отправки письма. Этот метод будет более процедурным по своей природе, без сложных логических конструкций:

```go
func (m *Mail) SendSMTPMessage(msg Message) error {
	if msg.From == "" {
		msg.From = m.FromAddress
	}

	if msg.FromName == "" {
		msg.FromName = m.FromName
	}

	data := map[string]any{
		"message": msg.Data,
	}

	msg.DataMap = data

	formattedMessage, err := m.buildHTMLMessage(msg)
	// Продолжение логики будет в следующей части
}
```

Здесь мы выполняем проверку: если поля `From` и `FromName` не заданы, то используются значения по умолчанию, которые были заданы в структуре `Mail`. Это полезно, так как не всегда при отправке письма будут указаны все параметры, и нужно предусмотреть использование значений по умолчанию.

Далее мы формируем карту данных `DataMap`, которую будем передавать в шаблон письма. Это позволит нам динамически подставлять значения в шаблон.

После этого вызываем функцию `buildHTMLMessage`, которая сгенерирует HTML-версию письма.

### Создание функции для генерации HTML-сообщения

Теперь реализуем метод `buildHTMLMessage`, который будет обрабатывать шаблон и возвращать готовый HTML-код письма:

```go
func (m *Mail) buildHTMLMessage(msg Message) (string, error) {
	templateToRender := "./templates/mail.html.gohtml"

	t, err := template.New("email-html").ParseFiles(templateToRender)
	if err != nil {
		return "", err
	}

	var tpl bytes.Buffer
	if err = t.ExecuteTemplate(&tpl, "body", msg.DataMap); err != nil {
		return "", err
	}

	formattedMessage := tpl.String()
	formattedMessage, err = m.inlineCSS(formattedMessage)
	if err != nil {
		return "", err
	}

	return formattedMessage, nil
}
```

Здесь происходит следующее:

1. Указываем путь к шаблону, который нужно рендерить (`templateToRender`).
2. Используем встроенный пакет `template` для обработки файла шаблона и создания объекта `t`.
3. Рендерим шаблон в буфер `tpl`, передавая туда данные из карты `DataMap`.
4. После успешной генерации HTML-кода, передаем его в функцию `inlineCSS`, которая будет отвечать за встроенную обработку CSS.

Этот метод возвращает готовый HTML-код письма, который можно будет отправить.

### Добавление встроенных стилей (inline CSS)

Одним из важных аспектов отправки писем является корректная обработка CSS. Для этого мы будем использовать сторонний пакет [premailer](https://github.com/vanng822/go-premailer), который автоматически преобразует стили в подходящий для email формат.

Реализуем метод `inlineCSS`:

```go
func (m *Mail) inlineCSS(s string) (string, error) {
	options := premailer.Options{
		RemoveClasses:     false,
		CssToAttributes:   false,
		KeepBangImportant: true,
	}

	prem, err := premailer.NewPremailerFromString(s, &options)
	if err != nil {
		return "", err
	}

	html, err := prem.Transform()
	if err != nil {
		return "", err
	}

	return html, nil
}
```

Метод работает следующим образом:

1. Задаем параметры для преобразования CSS: например, не удаляем классы и сохраняем важные правила.
2. Создаем объект `premailer` и передаем ему строку с HTML-кодом и наши настройки.
3. Вызываем метод `Transform`, который возвращает итоговый HTML с встроенными стилями.

Таким образом, наш HTML будет правильно отображаться в различных почтовых клиентах, что особенно важно, так как поддержка стилей в email-клиентах сильно ограничена.

### Импорт необходимых пакетов

Перед тем как продолжить, убедитесь, что установили следующие пакеты:

1. Для обработки CSS:

```sh
go get github.com/vanng822/go-premailer/premailer
```

2. Для работы с SMTP:

```sh
go get github.com/xhit/go-simple-mail/v2
```

Эти пакеты добавят необходимые зависимости в файл `go.mod` и обеспечат нас всем необходимым для корректной работы.

### Итак

Мы разобрали структуру и логику базовой реализации отправки email в Go. Далее мы продолжим дорабатывать этот код, добавив обработку ошибок, подключение к SMTP и другие важные аспекты.

---

На данном этапе у нас уже есть готовое HTML-сообщение с встроенными CSS-стилями, и теперь мы можем вернуться к функции `SendSMTPMessage`, чтобы продолжить реализацию логики отправки email через SMTP. Однако, прежде чем перейти к следующему шагу, стоит заметить, что на данный момент у нас есть только одна версия сообщения — HTML. Для полноценной работы системы также необходимо поддерживать текстовую (plain text) версию сообщения. Это важно, потому что некоторые email-клиенты не поддерживают HTML и будут использовать текстовую версию, если она доступна.

### Добавление текстовой версии сообщения

Начнем с того, что добавим текстовую версию сообщения. Для этого мы объявим новую переменную `plainMessage`, которая будет хранить текстовое письмо. Получим его через вызов функции `buildPlainTextMessage`. Однако такой функции пока нет, поэтому давайте её создадим.

Для экономии времени скопируем существующую функцию `buildHTMLMessage` и вставим её ниже, изменив название на `buildPlainTextMessage`. Давайте разберем, какие изменения необходимо внести:

```go
func (m *Mail) buildPlainTextMessage(msg Message) (string, error) {
    templateToRender := "./templates/mail.plain.gohtml"

    t, err := template.New("email-plain").ParseFiles(templateToRender)
    if err != nil {
        return "", err
    }

    var tpl bytes.Buffer
    if err = t.ExecuteTemplate(&tpl, "body", msg.DataMap); err != nil {
        return "", err
    }

    plainMessage := tpl.String()

    return plainMessage, nil
}
```

Обратите внимание на следующие изменения:

1. **Шаблон:** Вместо использования `mail.html.gohtml`, как в HTML-версии, мы используем `mail.plain.gohtml`, что позволяет работать с текстовой версией письма.
2. **Упрощение логики:** В отличие от HTML-версии, где нужно было встраивать CSS-стили, в текстовой версии нам этого не нужно, поэтому мы удаляем соответствующий код.

#### Настройка почтового сервера

Теперь, когда у нас есть как HTML, так и текстовая версии сообщения, давайте перейдем к настройке почтового сервера. Нам нужно создать SMTP-клиент, который будет использоваться для отправки писем. Это делается следующим образом:

```go
server := mail.NewSMTPClient()
server.Host = m.Host
server.Port = m.Port
server.Username = m.Username
server.Password = m.Password
server.Encryption = m.getEncryption(m.Encryption)
server.KeepAlive = false
server.ConnectTimeout = 10 * time.Second
server.SendTimeout = 10 * time.Second
```

Что здесь важно:

-   **Хост и порт:** Мы задаем их на основе значений, которые определены в структуре `Mail`.
-   **Шифрование:** Тип шифрования определяется через вызов функции `getEncryption`, которая возвращает соответствующий тип из пакета `go-simple-mail`.

### Реализация функции `getEncryption`

Функция `getEncryption` принимает строковый параметр и возвращает тип шифрования. Это позволяет поддерживать различные способы шифрования, такие как TLS, SSL или отсутствие шифрования, что особенно полезно при смене почтовых серверов.

Реализация функции:

```go
func (m *Mail) getEncryption(s string) mail.Encryption {
    switch s {
    case "tls":
        return mail.EncryptionSTARTTLS
    case "ssl":
        return mail.EncryptionSSLTLS
    case "none", "":
        return mail.EncryptionNone
    default:
        return mail.EncryptionSTARTTLS
    }
}
```

Эта функция поддерживает несколько вариантов шифрования, а в случае неопознанного параметра возвращает `STARTTLS` как наиболее безопасный вариант по умолчанию.

### Конфигурация времени ожидания и создание SMTP-клиента

После настройки шифрования и других параметров сервера, мы добавляем конфигурации времени ожидания:

-   **Время ожидания подключения (`ConnectTimeout`)** — установлено на 10 секунд.
-   **Время ожидания отправки (`SendTimeout`)** — также 10 секунд.

Создание SMTP-клиента выполняется следующим образом:

```go
smtpClient, err := server.Connect()
if err != nil {
    return err
}
```

Если при подключении возникает ошибка, мы возвращаем её для дальнейшей обработки.

### Формирование и настройка Email-сообщения

Теперь, когда соединение установлено, мы можем сформировать само письмо. Для этого создается объект `email` с помощью `mail.NewMSG()`, а затем задаются все необходимые атрибуты:

```go
email := mail.NewMSG()
email.SetFrom(msg.From).
    AddTo(msg.To).
    SetSubject(msg.Subject)
```

После этого добавляем тела письма:

1. **Текстовая версия:**

```go
email.SetBody(mail.TextPlain, plainMessage)
```

2. **HTML-версия как альтернатива:**

```go
email.AddAlternative(mail.TextHTML, formattedMessage)
```

Это позволяет email-клиентам выбрать наиболее подходящий формат отображения письма.

#### Работа с вложениями

Если в сообщении есть вложения, мы добавляем их следующим образом:

```go
if len(msg.Attachments) > 0 {
    for _, x := range msg.Attachments {
        email.AddAttachment(x)
    }
}
```

Метод `AddAttachment` принимает полный путь к файлу, который будет прикреплен к письму.

### Завершение отправки сообщения

В заключение, чтобы отправить письмо, мы вызываем метод `Send` у объекта `email`, передавая в него SMTP-клиент:

```go
err = email.Send(smtpClient)
if err != nil {
    return err
}

return nil
```

Если при отправке возникает ошибка, она возвращается для обработки, в противном случае функция возвращает `nil`.

### Заключение

Теперь у нас есть полноценная логика для отправки email-сообщений, включая поддержку как HTML, так и текстовых версий, а также возможность добавления вложений. В следующей лекции мы займемся добавлением маршрутов и обработчиков для обработки запросов на отправку email через наше приложение.
