
## Добавление почтового сервиса в `docker-compose.yml` и Makefile

### 1. Создание Dockerfile для почтового сервиса

Первым шагом было создание Dockerfile для нашего почтового сервиса. В корневой папке проекта (внутри папки `mail-service`) я создал новый файл с названием `mail-service.dockerfile`. Его содержимое практически идентично другим микросервисам в проекте. Основное отличие заключается в том, что я компилирую или копирую бинарный файл с именем `mailerApp` (с заглавной буквой "A") в папку `app` внутри контейнера.

Вот содержимое `mail-service.dockerfile`:

```dockerfile
FROM alpine:latest

RUN mkdir /app

COPY mailerApp /app

CMD [ "/app/mailerApp" ]
```

Как видите, создается директория `app`, куда копируется наш бинарный файл `mailerApp`, после чего контейнер запускается командой, указывающей на этот бинарник.

### 2. Изменения в Makefile

Теперь перейдем к изменениям в Makefile. В самом начале файла я добавил новую переменную:

```makefile
MAIL_BINARY=mailerApp
```

Эта переменная соответствует имени бинарного файла, который у нас указан в Dockerfile. Затем, в задаче `up_build`, которая выполняется перед запуском всех контейнеров, я добавил задачу `build_mail`, чтобы убедиться, что почтовый сервис компилируется вместе с остальными микросервисами:

```makefile
up_build: build_broker build_auth build_logger build_mail
```

Важно не забыть добавить `build_mail` в этот список, иначе почтовый сервис не будет собран перед запуском контейнеров. Далее я определил саму задачу `build_mail`, которая выглядит почти так же, как и задачи для других микросервисов:

```makefile
## build_mail: builds the mail binary as a linux executable
build_mail:
	@echo "Building mail binary..."
	cd ../mail-service && env GOOS=linux CGO_ENABLED=0 go build -o ${MAIL_BINARY} ./cmd/api
	@echo "Done!"
```

Основные изменения заключаются только в названии задачи и пути к директории. После выполнения команды `go build` в директории `../mail-service` создается бинарный файл `mailerApp`, который потом используется в Dockerfile.

Для пользователей Windows Makefile практически идентичен. Основное отличие заключается в использовании специфичных команд для компиляции на этой платформе. Важные изменения касаются строки с номером 49 (в Windows-версии файла), где добавлены команды для сборки бинарника в Windows.

### 3. Добавление почтового сервиса в `docker-compose.yml`

Следующий шаг — это добавление почтового сервиса в `docker-compose.yml`. Здесь основной сложностью являются переменные окружения, которые нужны для корректной работы почтового сервиса.

Сначала определяем путь к контексту и Dockerfile:

```yml
mailer-service:
    build:
        context: ./../mail-service
        dockerfile: ./../mail-service/mail-service.dockerfile
    restart: always
    deploy:
        mode: replicated
        replicas: 1
    environment:
        MAIL_DOMAIN: localhost
        MAIL_HOST: mailhog
        MAIL_PORT: 1025
        MAIL_ENCRYPTION: none
        MAIL_USERNAME: ""
        MAIL_PASSWORD: ""
        FROM_NAME: "John Smith"
        FROM_ADDRESS: john.smith@example.com
```

Контекст указывает на папку `mail-service`, а путь к Dockerfile точно соответствует файлу, который мы создали ранее. Что касается переменных окружения, они соответствуют тем, которые ожидаются в `main.go` файла почтового сервиса. Например, в качестве домена почты (`MAIL_DOMAIN`) используется `localhost`, а хостом (`MAIL_HOST`) указан `mailhog`, так как именно так называется контейнер MailHog, который мы используем для тестирования. Порт (`MAIL_PORT`) по умолчанию — `1025`, стандартный для MailHog.

Также важно правильно задать параметры шифрования (`MAIL_ENCRYPTION`), оставив значение `none` или пустым. Остальные параметры — это стандартные настройки, такие как имя отправителя и его email.

### 4. Запуск и проверка работы

Когда все настройки завершены, я открыл терминал и перешел в корневую папку проекта. Для запуска всех сервисов я выполнил команду:

```bash
make up_build
```

Эта команда останавливает уже запущенные контейнеры (если они есть), собирает все бинарники и запускает контейнеры заново. Если все сделано правильно, контейнеры будут успешно запущены и будут работать как ожидалось.

### 5. Дальнейшие шаги

На данный момент сервисы запущены, но мы еще не проверили их функциональность. Для этого нужно внести изменения в микросервис брокера, чтобы он мог принимать запросы на отправку почты. Также потребуется внести изменения во фронтенд. Эти задачи мы рассмотрим в следующей лекции.

---

Таким образом, этот пересказ включает все ключевые элементы оригинальной лекции, но представлен более структурированно и логически последовательно, что облегчает восприятие информации.
