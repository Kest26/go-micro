## Попытка запустить систему и проверить функциональность

### Вступление

На данном этапе проекта мы написали немало кода, поэтому пришло время протестировать систему и убедиться, что все работает корректно. Вполне возможно, что где-то могут быть ошибки, так как с момента последнего тестирования прошло довольно много времени, и мы добавили новые функции.

### Запуск и настройка Docker

Для начала я открываю терминал и перехожу в папку проекта, убедившись, что нахожусь в нужной директории. Теперь с помощью команды `make up_build` я собираю проект, чтобы создать Docker-образы и запустить их. Все собирается, что внушает оптимизм.

Следующий шаг — сборка Docker-образов и их запуск. Видно, что все контейнеры запущены, что также обнадеживает. Теперь я перейду к фронтенду: сначала остановлю его с помощью команды `make stop`, а затем снова запущу командой `make start`. Фронтенд запускается успешно.

### Проверка состояния микросервисов

Далее я перехожу в Docker Desktop, чтобы убедиться, что все сервисы, в частности брокер, успешно запущены. Вижу, что брокер пока еще не готов к работе, так как ожидает запуска RabbitMQ. Через некоторое время RabbitMQ запускается, и брокер начинает свою работу.

Теперь можно открыть веб-браузер и перейти к тестированию системы.

### Тестирование MongoDB

Первым делом я проверяю состояние базы данных. Я открываю MongoDB, подключаюсь к локальному серверу и проверяю коллекцию под названием logs, чтобы убедиться, что она пуста. Подключение успешно, и коллекция действительно пуста, что нам и нужно для тестирования.

### Тестирование брокера

Теперь переходим к тестированию брокера. Запускаю тест брокера, и он работает корректно. После этого проверяю функциональность аутентификации. Аутентификация также прошла успешно.

Загляну в MongoDB, чтобы убедиться, что запись об аутентификации была добавлена в коллекцию. Обновляю данные и вижу запись:

```json
{
    "_id": "66d9bb26987626cb84b8ac6c",
    "name": "authentication",
    "data": "admin@example.com logged in",
    "created_at": "2024-09-05T14:07:34.065+00:00",
    "updated_at": "2024-09-05T14:07:34.065+00:00"
}
```

Все работает корректно.

### Тестирование отправки почты

Теперь проверим отправку писем. Тест завершился с сообщением об успешной отправке. Перехожу в Mailhug и вижу, что письмо действительно было отправлено — это прекрасно.

### Тестирование логирования через RabbitMQ

Теперь самый важный момент. При нажатии на кнопку "Test Log" лог должен быть записан в систему, но на этот раз с использованием RabbitMQ. Запускаю тест и получаю ответ:

```json
{
    "error": false,
    "message": "logged via RabbitMQ"
}
```

Это отличный результат. Лог успешно записан через RabbitMQ. Данные, отправленные через запрос:

```json
{
    "action": "log",
    "log": {
        "name": "event",
        "data": "Some kind of data"
    }
}
```

Теперь я снова перехожу в MongoDB, чтобы убедиться, что запись действительно сохранена в коллекции. Обновляю данные и вижу следующую запись:

```json
{
    "_id": "66d9bd25987626cb84b8ac6d",
    "name": "event",
    "data": "Some kind of data",
    "created_at": "2024-09-05T14:16:05.029+00:00",
    "updated_at": "2024-09-05T14:16:05.030+00:00"
}
```

### Итоги

Все сработало с первого раза, что просто удивительно. Теперь у нас есть два способа обмена данными между микросервисами:

1. **Отправка JSON** — мы собираем информацию, сериализуем ее в формат JSON, отправляем ее на другой микросервис, где она десериализуется и обрабатывается. Затем получаем JSON-ответ.

2. **Очереди сообщений через RabbitMQ** — это удобный способ обмена данными между большим количеством микросервисов. Необходимо только убедиться, что микросервис, который прослушивает очередь (в нашем случае это listener), корректно обрабатывает все случаи и имеет логичное поведение по умолчанию.

### Введение в RPC

В следующем разделе курса мы рассмотрим еще один способ взаимодействия микросервисов, который значительно быстрее, чем работа с JSON. Этот метод называется RPC (Удаленный вызов процедур), и мы скоро начнем его изучать.
