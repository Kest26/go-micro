## Обновление файла `main.go` для запуска функции Listener

В этом уроке мы займемся обновлением файла `main.go` в микросервисе Listener, чтобы он начал прослушивать сообщения из очереди RabbitMQ. Мы пройдем по шагам и добавим необходимые изменения в код, чтобы реализовать эту задачу.

---

### Перемещение сообщения журнала

Первым делом, мы перенесем строку логирования, которая выводит сообщение о подключении к RabbitMQ. Сейчас она расположена не в самом подходящем месте, поэтому давайте переместим её ниже, в блок, который обрабатывает успешное подключение.

В текущем коде эта строка логирования может находиться в месте, где она выводится до установления соединения с RabbitMQ. Давайте переместим её в секцию `else`, чтобы она отображалась только тогда, когда соединение действительно установлено:

```go
if err != nil {
    log.Println("Failed to connect to RabbitMQ")
} else {
    log.Println("Connected to RabbitMQ!")
}
```

Теперь наше подключение выглядит более аккуратно и логично.

---

### Начало прослушивания сообщений

Следующим шагом является настройка прослушивания сообщений из RabbitMQ. Мы начнем с добавления простого сообщения в журнал, чтобы удостовериться, что наш Listener начал прослушивание:

```go
log.Println("Listening for and consuming RabbitMQ messages...")
```

Это сообщение будет выводиться в лог при успешном запуске прослушивания.

---

### Создание объекта Consumer

Для того чтобы начать потребление сообщений из очереди, нам необходимо создать объект `Consumer`. Для этого мы вызовем функцию `NewConsumer` из пакета `event`, передав ей соединение с RabbitMQ. Мы также обработаем возможные ошибки при создании Consumer:

```go
consumer, err := event.NewConsumer(RabbitConn)
if err != nil {
    log.Panic(err)
}
```

Если на этом этапе возникнет ошибка (например, если соединение с RabbitMQ не удалось установить), программа вызовет `panic` и завершится.

---

### Прослушивание и потребление событий

Теперь мы можем начать прослушивание очереди и потребление событий. Для этого вызовем метод `Listen` у объекта `consumer`, который мы только что создали. Этот метод принимает срез строк (slice of strings), который указывает, какие типы событий мы хотим прослушивать:

```go
err = consumer.Listen([]string{"log.INFO", "log.WARNING", "log.ERROR"})
if err != nil {
    log.Println(err)
}
```

Здесь мы указываем, что хотим прослушивать три типа событий: `log.INFO`, `log.WARNING` и `log.ERROR`. В реальном приложении вы можете указать любое количество типов событий и настроить их обработку по вашему усмотрению.

---

### Запуск и проверка

После того как все необходимые изменения внесены, давайте запустим наше приложение и проверим, что оно работает правильно. Для этого откроем терминал, перейдем в папку с нашим сервисом Listener и запустим команду `go run .`:

```bash
go run .
```

Если все сделано правильно, вы увидите следующее в терминале:

```bash
2024/09/03 09:07:44 Connected to RabbitMQ!
2024/09/03 09:07:44 Listening for and consuming RabbitMQ messages...
Waiting for message [Exchange, Queue] [logs_topic, amq.gen-wwUjS0UDl03guz26FW9GZg]
```

Это значит, что наш микросервис успешно подключился к RabbitMQ и начал прослушивание очереди для обработки сообщений.

---

### _Обратите внимание:_

При подключении к сервису RabbitMQ в строке подключения мы используем `localhost`, а не имя `rabbitmq`, т.к. мы запускаем код на локальной машине и отсюда пытаемся подключиться к RabbitMQ, который запущен в Docker-контейнере, порт которого Docker мапит с портом локальной машины.

`rabbitmq`, как имя хоста, относится к внутренней сети Docker, поэтому мы будем использовать это имя контейнера (rabbitmq) для подключения, когда будем запускать код внутри другого Docker-контейнера, который будет находиться в одной сети Docker с сервисом RabbitMQ.

---

### Заключение

На этом этапе наш Listener готов к работе. Следующим шагом будет модификация микросервиса Broker, чтобы он начал отправлять сообщения в очередь RabbitMQ, которые затем будут обработаны Listener'ом. Это позволит нашему приложению полноценно функционировать, обрабатывая и логируя события, поступающие через очередь сообщений.

В следующем уроке мы займемся этими изменениями и настроим наш Broker для отправки сообщений в очередь.
