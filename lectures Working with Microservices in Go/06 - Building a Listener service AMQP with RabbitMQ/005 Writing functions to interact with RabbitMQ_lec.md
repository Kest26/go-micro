# Написание функций для взаимодействия с RabbitMQ

## Часть 1

### Введение

Теперь, когда мы установили соединение с RabbitMQ, следующим шагом будет написание функций, которые позволят нам взаимодействовать с очередью, чтобы выполнять нужные задачи. Важный момент заключается в том, что я собираюсь поместить эти функции в отдельный пакет. Это сделано для того, чтобы часть кода, который мы напишем сейчас, можно было использовать повторно в других микросервисах, которым также потребуется взаимодействовать с очередью.

Например, брокер будет обязан добавлять сообщения в очередь. В то же время, наш слушающий сервис (listener service), по крайней мере на данном этапе, не будет помещать что-либо в очередь. Вместо этого очередь будет отправлять сообщения в этот сервис, который будет их прослушивать.

## Подготовка структуры проекта

Чтобы начать, давайте перейдём в папку нашего слушающего сервиса и создадим новую папку, которую я назову `event`, так как мы будем работать с событиями из очереди. Внутри этой папки я создам два файла: первый назову `consumer.go`, а второй — `event.go`.

```bash
listener-service/
│
└───event/
    │   consumer.go
    │   event.go
```

---

## Создание файла `consumer.go`

Начнём с файла `consumer.go`. Сначала определим, что он принадлежит к пакету `event`.

```go
package event
```

Теперь давайте импортируем необходимые библиотеки. Мы будем использовать библиотеку RabbitMQ, и для удобства и единообразия зададим ей псевдоним `amqp`. Эта библиотека находится по следующему пути: `github.com/rabbitmq/amqp091-go`.

```go
import (
    amqp "github.com/rabbitmq/amqp091-go"
)
```

### Определение структуры Consumer

Первое, что нам нужно сделать, — это объявить новый тип `Consumer`. Это будет структура, которая будет использоваться для получения событий из очереди.

```go
type Consumer struct {
    conn      *amqp.Connection
    queueName string
}
```

Эта структура имеет два поля:

-   `conn` — указатель на соединение `amqp.Connection`, которое будет использоваться для связи с RabbitMQ.
-   `queueName` — строка, содержащая имя очереди, с которой будет работать `Consumer`.

### Создание функции-конструктора NewConsumer

Теперь нам нужно создать экземпляр этой структуры с помощью функции-конструктора `NewConsumer`. Эта функция будет принимать в качестве параметра указатель на соединение `amqp.Connection` и возвращать экземпляр `Consumer`, а также возможную ошибку.

```go
func NewConsumer(conn *amqp.Connection) (Consumer, error) {
    consumer := Consumer{
        conn: conn,
    }

    err := consumer.setup()
    if err != nil {
        return Consumer{}, err
    }

    return consumer, nil
}
```

В функции `NewConsumer` создается экземпляр `Consumer`, и затем вызывается метод `setup` для настройки потребителя. Если настройка прошла успешно, функция возвращает экземпляр `Consumer`. В противном случае, возвращается ошибка.

### Настройка Consumer: Метод setup

Метод `setup` выполняет основные настройки для работы с очередью, включая открытие канала и объявление обмена (exchange). Эти термины относятся к AMQP (Advanced Message Queuing Protocol), который используется в RabbitMQ.

```go
func (consumer *Consumer) setup() error {
    channel, err := consumer.conn.Channel()
    if err != nil {
        return err
    }

    return declareExchange(channel)
}
```

В методе `setup` создается канал через соединение `consumer.conn`. Канал нужен для взаимодействия с RabbitMQ. Если создание канала прошло успешно, вызывается функция `declareExchange`, которая объявляет обмен. Если возникла ошибка, функция возвращает её.

### Создание структуры Payload

Теперь давайте объявим еще один тип данных, который нам понадобится для отправки данных в очередь — это структура `Payload`. Она будет представлять собой данные, которые мы будем отправлять и получать из очереди.

```go
type Payload struct {
    Name string `json:"name"`
    Data string `json:"data"`
}
```

Структура `Payload` имеет два поля:

-   `Name` — имя события, которое будет отправлено в формате JSON.
-   `Data` — данные события в формате JSON.

Это простая структура, которая позволяет передавать имя события и его данные в формате JSON. Например, если мы отправляем журнал событий, поле `Name` может содержать тип события (например, "error"), а поле `Data` — само сообщение.

---

## Создание файла `event.go`

Теперь перейдём к файлу `event.go`, в котором мы будем определять функцию для объявления обмена в RabbitMQ.

### Определение функции declareExchange

В этом файле мы также определим пакет как `event` и импортируем библиотеку RabbitMQ с тем же псевдонимом `amqp`.

```go
package event

import (
    amqp "github.com/rabbitmq/amqp091-go"
)
```

Теперь определим функцию `declareExchange`, которая будет объявлять обмен. Эта функция принимает в качестве параметра указатель на канал `amqp.Channel` и возвращает ошибку в случае неудачи.

```go
func declareExchange(ch *amqp.Channel) error {
    return ch.ExchangeDeclare(
        "logs_topic", // name
        "topic",      // type
        true,         // durable?
        false,        // auto-deleted?
        false,        // internal?
        false,        // no-wait?
        nil,          // arguments?
    )
}
```

Функция `declareExchange` объявляет обмен с именем `logs_topic` и типом `topic`. Здесь мы указываем несколько параметров:

-   **durable** — указывает на то, что обмен будет сохранён при перезапуске RabbitMQ, установим его в `true`.
-   **auto-deleted** — указывает на то, что обмен будет удалён, когда больше не будет очередей, связанных с ним, установим его в `false`.
-   **internal** — если этот флаг установлен, обмен используется только для внутренних целей RabbitMQ, установим в `false`.
-   **no-wait** — говорит RabbitMQ не ждать ответа от сервера при объявлении обмена, установим в `false`.
-   **arguments** — дополнительные параметры, передаем `nil`, так как в нашем случае они не нужны.

Этот обмен будет использоваться для регистрации различных типов сообщений, отправляемых в очередь.

### Написание функции Listen

Теперь вернёмся к файлу `consumer.go` и создадим функцию `Listen`, которая будет отвечать за прослушивание очереди и обработку поступающих сообщений. Эта функция принимает список тем (topics), которые нужно прослушивать.

```go
func (consumer *Consumer) Listen(topics []string) error {
    ch, err := consumer.conn.Channel()
    if err != nil {
        return err
    }
    defer ch.Close()

    // Продолжение функции будет рассмотрено во второй части лекции
}
```

Функция `Listen` сначала создаёт канал через соединение `consumer.conn`. Если создание канала прошло успешно, необходимо закрыть его после завершения работы с помощью `defer`, чтобы избежать утечки ресурсов.

Далее в методе будет реализована логика для получения сообщений из очереди, но эта часть будет рассмотрена во второй части лекции.

### Итог 1 части лекции

На этом завершается первая часть лекции по написанию функций для взаимодействия с RabbitMQ. В этой части мы настроили структуру проекта, создали базовые структуры данных, объявили обмен, а также начали разработку функции `Listen`, которая будет обрабатывать сообщения из очереди. В следующей части мы продолжим работу с этой функцией и рассмотрим более детально, как получать и обрабатывать сообщения из RabbitMQ.

---

---

---

## Часть 2

---

### Введение

Продолжая предыдущую часть лекции, мы займемся реализацией функций для работы с RabbitMQ. В этой части мы сосредоточимся на создании и настройке очередей, связывании их с топиками и обработке входящих сообщений.

Давайте вернемся к нашему файлу `event.go` и посмотрим, как объявить случайную очередь, а затем перейдем к обработке сообщений в `consumer.go`.

### Объявление случайной очереди

В файле `event.go` мы начнем с объявления новой функции:

```go
func declareRandomQueue(ch *amqp.Channel) (amqp.Queue, error) {
```

Эта функция принимает канал (`ch`), который является указателем на `amqp.Channel`, и возвращает два значения: объект `amqp.Queue` и возможную ошибку.

Теперь давайте рассмотрим саму реализацию функции. Она довольно проста, хотя и требует внимания к деталям. Мы возвращаем результат вызова метода `QueueDeclare` для нашего канала:

```go
return ch.QueueDeclare(
    "",    // имя очереди оставляем пустым, чтобы RabbitMQ сгенерировал случайное имя
    false, // durable? - эта очередь не сохраняется при перезапуске
    false, // delete when unused? - не удалять, когда не используется
    true,  // exclusive? - очередь используется только текущим соединением
    false, // no-wait? - ждать завершения операции
    nil,   // аргументы - у нас нет дополнительных аргументов
)
```

-   **"" — Имя очереди**: Мы оставляем это поле пустым, чтобы RabbitMQ сгенерировал случайное имя для очереди.
    -   Этот параметр — имя очереди.
-   **Durable**: Устанавливаем `false`, так как эта очередь не должна сохраняться после перезапуска RabbitMQ.
    -   Этот параметр указывает, нужно ли сохранять очередь при перезапуске брокера.
-   **Delete when unused**: Снова `false`, чтобы очередь не удалялась, когда не используется.
    -   Этот параметр управляет удалением очереди, когда она перестает использоваться.
-   **Exclusive**: Устанавливаем `true`, чтобы очередь была доступна только для текущего соединения.
    -   Этот параметр указывает, что очередь используется только текущим каналом, и к ней не может быть доступа из других каналов.
-   **No-wait**: Устанавливаем `false`, чтобы клиент ждал завершения операции.
    -   Этот параметр указывает, нужно ли ждать подтверждения от сервера после выполнения операции.
-   **Аргументы**: У нас нет дополнительных аргументов, поэтому используем `nil`.
    -   Этот параметр — аргументы.

После объявления этой функции, т.е. когда мы объявили очередь, мы можем перейти к файлу `consumer.go`, где будем использовать её.

### Обработка сообщений в файле `consumer.go`

В файле `consumer.go`, после того как мы закрыли канал (`defer ch.Close()`), мы вызываем нашу новую функцию `declareRandomQueue` для получения случайной очереди:

```go
q, err := declareRandomQueue(ch)
if err != nil {
    return err
}
```

Если функция вернет ошибку, мы ее обработаем. Если ошибки нет, то мы можем продолжить работу с очередью.

### Привязка очереди к топикам (темам)

Теперь, когда у нас есть очередь, мы можем привязать ее к топикам. У нас есть срез строк под названием `topics`, и мы будем проходить по нему в цикле `for`, привязывая каждый топик к очереди:

Cвязываем нашу очередь с темами, которые переданы в функцию `Listen`:

```go
for _, s := range topics {
    err := ch.QueueBind(
        q.Name,       // имя очереди
        s,            // текущая тема из списка
        "logs_topic", // имя обменника
        false,        // no-wait?
        nil,          // аргументы
    )
    if err != nil {
        return err
    }
}
```

Здесь мы проходим по каждой теме (`s`) и связываем её с нашей случайной очередью с помощью метода `QueueBind`, т.е. мы привязываем каждый топик к нашей случайно сгенерированной очереди `q.Name`, используя exchange `logs_topic`. Имя обменника (`logs_topic`) захардкожено для упрощения.

Если возникает ошибка при привязке, мы ее обрабатываем.

### Потребление сообщений

Теперь, когда очередь настроена, мы можем начать потреблять сообщения. Для этого вызываем метод `Consume` канала `ch`:

```go
messages, err := ch.Consume(
    q.Name, // имя очереди
    "",     // имя потребителя (можно оставить пустым)
    true,   // auto-ack?
    false,  // exclusive?
    false,  // no-local?
    false,  // no-wait?
    nil,    // аргументы
)
if err != nil {
    return err
}
```

Мы получаем канал, через который будем получать сообщения, и обрабатываем возможные ошибки.

-   **Auto-ack**: Устанавливаем `true`, чтобы сообщения автоматически подтверждались после получения.
-   **Exclusive**: Устанавливаем `false`, чтобы разрешить другие соединения.
-   **No-local**: Устанавливаем `false`, чтобы разрешить получение сообщений от других соединений.
-   **No-wait**: Устанавливаем `false`, чтобы клиент ждал завершения операции.

### Обработка сообщений в фоне

Мы хотим, чтобы потребление сообщений происходило постоянно, пока приложение не будет завершено. Для этого мы объявляем канал `forever` и запускаем горутину для обработки сообщений.

Создаём канал `forever`, который будет удерживать наше приложение от завершения:

```go
forever := make(chan bool)
```

Теперь запускаем новую горутину для обработки сообщений:

```go
go func() {
    for d := range messages {
        var payload Payload
        _ = json.Unmarshal(d.Body, &payload)

        go handlePayload(payload)
    }
}()
```

-   Мы создаем бесконечный цикл, который обрабатывает каждое полученное сообщение.
-   Здесь мы проходим по каждому сообщению из очереди и десериализуем его тело (`d.Body`) в структуру `Payload`.
-   Затем вызываем функцию `handlePayload` в новой горутине и передаём в неё структуру `Payload` (в которой находится тело) для обработки этого сообщения.

### Ожидание сообщений

Чтобы наше приложение не завершилось мгновенно сразу после запуска, мы используем блокирующую операцию:

-   Выводим сообщение и блокируем выполнение с помощью канала `forever`:

```go
fmt.Printf("Waiting for message [Exchange, Queue] [logs_topic, %s]\n", q.Name)
<-forever
```

Теперь программа будет ждать и обрабатывать сообщения, пока вы не прервете ее выполнение.

### Обработка полезной нагрузки (Payload)

Теперь создадим функцию `handlePayload`, которая будет обрабатывать разные типы событий, получаемых из RabbitMQ. Она будет управлять действиями, которые мы выполняем на основе полученных данных.

```go
func handlePayload(payload Payload) {
    switch payload.Name {
    case "log", "event":
        err := logEvent(payload)
        if err != nil {
            log.Println(err)
        }
    case "auth":
        // здесь может быть логика аутентификации
    default:
        err := logEvent(payload)
        if err != nil {
            log.Println(err)
        }
    }
}
```

В этой функции мы используем `switch`, чтобы определить тип события (`payload.Name`) и выполнить соответствующее действие. Например, если это лог или событие, вызываем функцию `logEvent`, которую мы еще не реализовали, но напишем ее позже.

### Stub для функции logEvent

Создаём заглушку для функции `logEvent`, которую мы реализуем в следующей лекции:

```go
func logEvent(entry Payload) error {
    // Заглушка для логирования события
}
```

---

### Заключение

На этом мы завершаем лекцию. В следующей лекции мы реализуем функцию `logEvent`, которая будет отвечать за обработку и логирование событий, полученных из RabbitMQ, т.е. мы реализуем логику для функции `logEvent`, которая будет управлять записью событий в лог. Этот процесс несложный, и мы детально его разберем в следующей лекции.
