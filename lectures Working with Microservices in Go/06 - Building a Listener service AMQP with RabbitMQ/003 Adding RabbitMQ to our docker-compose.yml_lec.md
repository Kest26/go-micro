## Добавление RabbitMQ в наш docker-compose.yml

---

### Шаг 1: Подготовка к подключению RabbitMQ

На текущий момент у нас есть пустая функция `main` для нашего сервиса-слушателя (Listener). Как упоминается в комментариях, первой задачей будет установление подключения к RabbitMQ. Для этого нам необходимо добавить RabbitMQ в файл Docker Compose. Давайте откроем файл `docker-compose.yml`, находящийся в корневой директории проекта.

---

### Шаг 2: Поиск подходящего образа RabbitMQ

Прежде чем добавлять RabbitMQ в Docker Compose, давайте посмотрим на доступные образы на Docker Hub. Переходим по ссылке:

```
https://hub.docker.com/_/rabbitmq
```

На этой странице доступно множество различных образов RabbitMQ. Мы не будем использовать релиз-кандидаты (обозначаются как RC), так как они могут быть нестабильными. Также нам не нужен полный образ с лишними компонентами, который занимает больше места, чем необходимо. Для наших целей мы выберем образ `3.9.14-alpine`, который является облегченным и стабильным вариантом.

Если вам интересно попробовать версию с веб-консолью для управления RabbitMQ, вы можете выбрать и её, но для нашего проекта мы используем указанную выше версию.

---

### Шаг 3: Добавление RabbitMQ в Docker Compose

Теперь вернемся в IDE и добавим RabbitMQ в наш `docker-compose.yml`. Добавим новую секцию для RabbitMQ в конце файла, на том же уровне, что и другие сервисы:

```yml
rabbitmq:
  image: 'rabbitmq:3.9-alpine'
  ports:
    - "5672:5672"
  deploy:
    mode: replicated
    replicas: 1
  volumes:
    - ./db-data/rabbitmq/:/var/lib/rabbitmq/
```

- **`image`**: Здесь мы указываем образ RabbitMQ, который будет использоваться. Мы выбрали `rabbitmq:3.9-alpine`.
- **`ports`**: Настроим маппинг портов, где порт 5672 в контейнере будет доступен на том же порту на локальной машине. Это позволяет взаимодействовать с RabbitMQ с хост-машины.
- **`deploy`**: Устанавливаем режим развертывания `replicated` с количеством реплик, равным одной. Это необходимо, так как RabbitMQ не может одновременно работать в нескольких экземплярах, так как это приведет к проблемам с синхронизацией очередей.
- **`volumes`**: Создаем том для хранения данных RabbitMQ на локальной машине, что позволяет сохранить состояние при перезапуске контейнера.

---

### Шаг 4: Запуск RabbitMQ с помощью Docker Compose

Теперь, когда мы внесли необходимые изменения, можно сохранить файл и открыть терминал. Очистим экран и в корневой папке проекта выполним команду для запуска всех сервисов:

```sh
docker-compose up -d
```

Эта команда поднимет все сервисы, включая RabbitMQ. Если при выполнении команды возникнет ошибка, как это произошло у меня, проверьте наличие возможных опечаток. Например, я допустил ошибку в имени директивы `volumes`, что вызвало проблему. Исправив ошибку, повторите команду:

```sh
docker-compose up -d
```

После этого RabbitMQ должен запуститься, хотя может потребоваться некоторое время для его полной инициализации.

---

### Шаг 5: Проблемы с остановкой RabbitMQ и обходные решения

Стоит отметить, что иногда RabbitMQ может быть капризным при попытке его остановки с помощью команды:

```sh
docker-compose down
```

Если RabbitMQ отказывается завершать работу, можно использовать обходное решение — остановить весь Docker через меню и перезапустить его. Это удалит все работающие контейнеры, включая RabbitMQ. Это известная проблема в последней версии RabbitMQ, и, возможно, на момент прохождения курса она уже будет устранена.

---

### Заключение

Теперь, когда RabbitMQ работает, в следующей лекции мы модифицируем файл `main.go` и попробуем подключиться к RabbitMQ. Мы просто установим соединение и выйдем из программы, чтобы убедиться, что всё работает корректно. Давайте приступим к следующему шагу!
