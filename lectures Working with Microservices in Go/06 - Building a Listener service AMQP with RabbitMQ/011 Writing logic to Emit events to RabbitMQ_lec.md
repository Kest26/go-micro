## Написание логики для отправки событий в RabbitMQ

**Введение**

В этом шаге мы займемся написанием замещающей функции для логирования событий. Как я уже говорил ранее, это функция `logItem`, которая находится в файле `handlers.go` внутри папки `cmd/api` в сервисе брокера. Мы её оставили для справки, но теперь создадим новую, которая будет не просто записывать события в лог, но и отправлять их в RabbitMQ.

Для реализации этого нам потребуется создать новый файл в папке `event` внутри нашего сервиса брокера. У нас уже есть файлы `event.go` и `consumer.go`, и мы будем использовать часть кода из них для данного сервиса. Однако нам также потребуется новый файл.

---

### 1. Создание файла `emitter.go`

Назовем наш новый файл `emitter.go`. Как и другие файлы, он будет находиться в пакете `event`. Для работы с RabbitMQ нам понадобится импортировать соответствующий пакет. Мы можем просто скопировать строку импорта из файла `event.go`, чтобы избежать ошибок при написании:

```go
amqp "github.com/rabbitmq/amqp091-go"
```

Вставляем этот импорт в файл `emitter.go`. Этот файл будет отвечать за отправку событий в очередь RabbitMQ. Теперь начнем с создания нового типа.

---

### 2. Определение структуры `Emitter`

Создадим новый тип `Emitter`, который будет структурой. У этой структуры будет одно поле — соединение с RabbitMQ:

```go
type Emitter struct {
	connection *amqp.Connection
}
```

Теперь мы можем добавить методы для этой структуры. Первый метод, который мы создадим, будет называться `setup`.

---

### 3. Метод `setup`

Метод `setup` будет ответственен за настройку канала связи с RabbitMQ. Этот метод может вернуть ошибку, если возникнут проблемы с подключением. Логика здесь несложная: мы создаем канал и проверяем наличие ошибки. Если ошибка возникла, мы возвращаем её.

```go
func (e *Emitter) setup() error {
	channel, err := e.connection.Channel()
	if err != nil {
		return err
	}

	defer channel.Close() // Закрываем канал после завершения работы, чтобы избежать утечек ресурсов.
	return declareExchange(channel) // Объявляем обменник, как это делается при чтении из очереди.
}
```

Этот код аналогичен тому, что мы уже делали в сервисе Listener. Важная часть — это правильная настройка обменника, что позволяет RabbitMQ эффективно маршрутизировать сообщения.

---

### 4. Метод `Push` для отправки событий

Теперь переходим к основной части — методу `Push`, который будет отправлять события в очередь RabbitMQ. Метод принимает два аргумента: само событие в виде строки и уровень серьезности (severity), который также представлен строкой. Метод может вернуть ошибку в случае неудачи.

```go
func (e *Emitter) Push(event string, severity string) error {
	channel, err := e.connection.Channel()
	if err != nil {
		return err
	}
	defer channel.Close() // Закрываем канал после завершения работы.

	log.Println("Pushing to channel") // Для отладки выводим сообщение в лог о процессе отправки.
```

Теперь самое интересное — как мы публикуем событие. Для этого мы вызываем метод `Publish` на объекте канала:

```go
	err = channel.Publish(
		"logs_topic",    // Exchange, куда отправляем сообщение.
		severity,        // Маршрутный ключ, определяющий уровень серьезности.
		false,           // Обязательно ли доставить сообщение (mandatory).
		false,           // Доставить немедленно (immediate).
		amqp.Publishing{
			ContentType: "text/plain", // Указываем тип содержимого — обычный текст.
			Body:        []byte(event), // Тело сообщения — наше событие, преобразованное в срез байтов.
		},
	)
	if err != nil {
		return err
	}

	return nil
}
```

Этот метод публикует событие в обменник `logs_topic`, используя уровень серьезности (severity) в качестве маршрутного ключа. Мы можем использовать различные уровни, такие как `log.info`, `log.warning` или `log.error`. Если возникает ошибка, она возвращается вызывающей функции.

---

### 5. Создание функции `NewEventEmitter`

Следующим шагом мы создадим функцию, которая будет возвращать новый объект `Emitter`. Эта функция принимает в качестве аргумента соединение с RabbitMQ и потенциально может вернуть ошибку, если настройка не удастся:

```go
func NewEventEmitter(conn *amqp.Connection) (Emitter, error) {
	emitter := Emitter{
		connection: conn, // Заполняем поле соединения.
	}

	err := emitter.setup() // Вызываем метод setup для настройки.
	if err != nil {
		return Emitter{}, err
	}

	return emitter, nil // Если ошибок нет, возвращаем объект emitter.
}
```

Эта функция создает новый объект типа `Emitter`, настраивает его и возвращает либо готовый объект, либо ошибку, если настройка не удалась.

---

### 6. Подведение итогов

Мы создали все необходимые компоненты для отправки событий в RabbitMQ. Теперь в следующих шагах мы будем использовать эти функции для замены текущей логики в файле `handlers.go`. Наш новый код позволит брокеру отправлять сообщения в очередь RabbitMQ, откуда другие сервисы смогут их получать и обрабатывать.

Перед тем как двигаться дальше, стоит еще раз убедиться, что обменник имеет правильное имя, чтобы избежать проблем в дальнейшем.

---

**Заключение**

Мы успешно написали логику для отправки событий в RabbitMQ, создав новый файл `emitter.go` и определив в нем структуру `Emitter` с методами `setup` и `Push`. Это позволит брокеру отправлять события в RabbitMQ, откуда их смогут забирать другие микросервисы.
