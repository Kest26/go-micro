## Подключение к RabbitMQ в Go

В этом разделе мы создадим и протестируем подключение к RabbitMQ в нашем новом сервисе `listener`. Основная цель этой лекции — успешно установить соединение с RabbitMQ, что является первым важным шагом в процессе работы с очередями сообщений. Мы рассмотрим, как использовать сторонний пакет для работы с RabbitMQ, как организовать попытки подключения с экспоненциальным откатом и как правильно закрывать соединение по завершении работы программы.

### Установка необходимого пакета

Для начала нам понадобится сторонний пакет, который обеспечит взаимодействие с RabbitMQ. Этот пакет реализует протокол AMQP (Advanced Messaging Queue Protocol). Чтобы его установить, откройте терминал, перейдите в директорию вашего сервиса `listener-service` и выполните команду:

```sh
go get github.com/rabbitmq/amqp091-go
```

Эта команда загрузит и установит пакет, необходимый для работы с RabbitMQ. Пакет `amqp091-go` заменил старый пакет, разработанный сообществом, и многие разработчики до сих пор используют для него псевдоним `amqp` из-за привычки и удобства. Это делает код более читаемым и понятным для других разработчиков.

### Импорт пакета и использование псевдонима

После того как пакет установлен, мы можем импортировать его в файл `main.go`. Мы будем использовать псевдоним `amqp`, что является общепринятой практикой среди разработчиков, работающих с RabbitMQ. Использование псевдонима делает код чище и понятнее, особенно если кто-то другой будет работать с этим кодом.

Добавьте импорт пакета в файл `main.go`:

```go
package main

import (
	"fmt"
	"log"
	"math"
	"os"
	"time"

	amqp "github.com/rabbitmq/amqp091-go"
)
```

### Создание функции подключения

Теперь мы создадим функцию `connect`, которая будет устанавливать соединение с RabbitMQ. Эта функция будет возвращать указатель на структуру `amqp.Connection` и ошибку, если соединение не удалось установить.

Для начала создадим переменные, которые понадобятся для реализации механизма подключения с экспоненциальным откатом:

```go
func connect() (*amqp.Connection, error) {
	var counts int64
	var backOff = 1 * time.Second
	var connection *amqp.Connection
```

Переменная `counts` отслеживает количество попыток подключения, `backOff` задает начальное время ожидания перед повторной попыткой, а переменная `connection` будет содержать ссылку на успешное подключение.

### Организация попыток подключения с экспоненциальным откатом

RabbitMQ может запускаться медленно, но после запуска работает стабильно. Поэтому мы будем использовать цикл с экспоненциальным откатом для попыток подключения к RabbitMQ. Это означает, что время ожидания между попытками подключения будет увеличиваться с каждым неудачным подключением, что предотвращает перегрузку сервера повторными запросами.

Цикл подключения выглядит следующим образом:

```go
	for {
		c, err := amqp.Dial("amqp://guest:guest@localhost")
		if err != nil {
			fmt.Println("RabbitMQ not yet ready...")
			counts++
		} else {
			connection = c
			break
		}
```

Здесь мы используем метод `amqp.Dial`, чтобы попытаться подключиться к RabbitMQ. Если попытка подключения не удалась, мы увеличиваем счетчик `counts` и выводим сообщение, что RabbitMQ еще не готов. Если подключение удалось, мы сохраняем его в переменную `connection` и выходим из цикла.

---

### _ОБРАТИТЕ ВНИМАНИЕ:_

В строке подключения к RabbitMQ мы указали `localhost`, вместо `rabbitmq`. Мы это сделали для того, чтобы проверить подключение к сервису RabbitMQ из локальной машины, т.к., когда мы будем проверять соединение, наш код пока ещё не будет запущен внутри Docker-контейнера, а сам RabbitMQ мы запустим в Docker (через `docker-compose.yml`).

#### Ключевая деталь: Docker и localhost

Когда мы запускаем код на своей локальной машине и используем `localhost`, мы пытаемся подключиться к сервису, который работает **на этой же машине**. Но в нашем случае, RabbitMQ запущен в Docker, и, казалось бы, `localhost` не должен работать, так как Docker-контейнеры изолированы. Однако есть важная особенность.

#### Как Docker работает с сетью и портами

Docker автоматически мапит порты контейнера на порты твоей локальной машины, если это явно указано в `docker-compose.yml` (или docker run). Например, если мы запускаем контейнер с RabbitMQ и указываешь, что порт `5672` (стандартный порт RabbitMQ) на контейнере должен быть доступен на этом же порту на нашей локальной машине, то наш код, запущенный на локальной машине, может подключиться к RabbitMQ через `localhost:5672`.

#### Пример, как это работает:

Если в `docker-compose.yml` или при запуске контейнера мы указали:

```yaml
ports:
    - "5672:5672"
```

Это значит, что Docker прокинет **порт `5672` контейнера** на **порт `5672` нашей локальной машины**. Теперь, когда наш код использует `localhost:5672`, он фактически подключается к порту `5672` нашей локальной машины, но этот порт связан с контейнером RabbitMQ.

#### Почему `localhost` будет работать в данной ситуации:

-   **Когда мы используем `localhost`**, мы фактически подключаемся к порту 5672 на нашей локальной машине.
-   **Docker прокинул этот порт из контейнера RabbitMQ на нашу локальную машину**.
-   Поэтому `localhost:5672` работает и позволяет коду на локальной машине подключиться к RabbitMQ, который работает внутри Docker.

#### Почему `rabbitmq` не будет работать:

`rabbitmq` как имя хоста относится к внутренней сети Docker. Если бы мы запускали код внутри другого Docker-контейнера, и эти контейнеры находились в одной сети Docker, то мы бы использовали имя контейнера (`rabbitmq`) для подключения.

**Но поскольку наш код работает на локальной машине, имя `rabbitmq` не распознается как адрес.** Внешняя сеть (наша локальная машина) не знает о внутренней сети Docker и не может использовать эти имена.

#### Итог:

-   **`localhost` работает** потому, что Docker прокинул порт 5672 на нашу локальную машину.
-   **`rabbitmq` не работает** на локальной машине, так как это имя контейнера, доступное только внутри Docker-сети.

---

Это было небольшое отступление, тему которого было важно упомянуть. Продолжаем дальше.

### Ограничение количества попыток подключения

Важно ограничить количество попыток подключения, чтобы избежать бесконечного цикла в случае, если сервер недоступен по каким-то причинам. Для этого мы проверяем значение счетчика `counts`:

```go
		if counts > 5 {
			fmt.Println(err)
			return nil, err
		}
```

Если количество попыток подключения превысило пять, функция возвращает ошибку и завершает работу. Если подключение все еще не удалось, мы увеличиваем время ожидания перед следующей попыткой:

```go
		backOff = time.Duration(math.Pow(float64(counts), 2)) * time.Second
		log.Println("backing off...")
		time.Sleep(backOff)
	}
```

Здесь мы используем функцию `math.Pow`, чтобы увеличить время ожидания в соответствии с количеством попыток. Время ожидания увеличивается по экспоненте, что позволяет избежать частых запросов к серверу. После ожидания функция снова пытается установить соединение.

### Возвращение результата функции подключения

Если подключение удалось, функция возвращает указатель на объект `amqp.Connection` и `nil` в качестве ошибки:

```go
	return connection, nil
}
```

Если после пяти попыток подключение не удалось, функция возвращает `nil` вместо соединения и ошибку, которая может быть обработана в вызывающей функции.

### Использование функции подключения в `main`

Теперь, когда функция `connect` готова, мы можем вызвать её в функции `main`, чтобы установить соединение с RabbitMQ. Если подключение удалось, мы выводим сообщение об успешном подключении и закрываем соединение по завершении работы программы:

```go
func main() {
	// try to connect to rabbitmq
	rabbitConn, err := connect()
	if err != nil {
		log.Println(err)
		os.Exit(1)
	}
	defer rabbitConn.Close()
	log.Println("Connected to RabbitMQ!")

	// start listening for messages

	// create consumer

	// watch the queue and consume events
}
```

В случае успешного подключения функция выводит сообщение "Connected to RabbitMQ!" и завершается. В конце программы мы используем `defer`, чтобы закрыть соединение и избежать утечки ресурсов.

### Тестирование подключения

Чтобы протестировать наше подключение, откройте терминал, перейдите в директорию listener-service и выполните команду:

```sh
go run main.go
```

Если всё выполнено правильно, вы увидите сообщение "Connected to RabbitMQ!" в консоли. Это означает, что соединение было установлено успешно, и программа завершила свою работу, закрыв соединение.

### Заключение

Успешное подключение к RabbitMQ — это первый и важный шаг в работе с очередями сообщений. В дальнейшем мы начнем взаимодействовать с RabbitMQ, создав потребителя (consumer) и начав обрабатывать сообщения в очереди. Этот процесс будет описан в следующих лекциях.
