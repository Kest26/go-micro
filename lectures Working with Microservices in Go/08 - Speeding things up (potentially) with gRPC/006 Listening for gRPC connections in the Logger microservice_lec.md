## Подключение gRPC в микросервисе Logger: Начало работы с прослушиванием gRPC соединений

### Введение
На данном этапе, когда у нас уже написана функция `WriteLog` для записи логов, пришло время настроить прослушивание gRPC-соединений. Это важный шаг для обеспечения взаимодействия между клиентами и сервером через gRPC. Мы создадим функцию, которая будет запускать gRPC-сервер и слушать входящие соединения. Далее, эту функцию мы вызовем из файла `main.go`. В этой лекции мы сосредоточимся на настройке сервера gRPC в файле `grpc.go` и интеграции его с основным приложением.

### Создание функции прослушивания gRPC
Начнем с того, что объявим функцию `gRPCListen` с получателем `app` (указатель на конфигурацию приложения). Эта функция не принимает параметров и не возвращает значений. Она будет отвечать за прослушивание соединений на порте, указанном в конфигурации.

Пример кода:

```go
func (app *Config) gRPCListen() {
    // Создаем переменную lis (listener) и обрабатываем ошибку
    lis, err := net.Listen("tcp", fmt.Sprintf(":%s", gRpcPort))
    if err != nil {
        log.Fatalf("Failed to listen for gRPC: %v", err)
    }
    
    // Создаем gRPC-сервер
    s := grpc.NewServer()

    // Регистрируем сервис
    logs.RegisterLogServiceServer(s, &LogServer{Models: app.Models})

    // Выводим сообщение о старте сервера
    log.Printf("gRPC Server started on port %s", gRpcPort)

    // Начинаем прослушивание
    if err := s.Serve(lis); err != nil {
        log.Fatalf("Failed to listen for gRPC: %v", err)
    }
}
```

#### Подключение TCP прослушивателя
В начале функции мы создаем TCP-подключение для прослушивания входящих соединений. Для этого используется функция `net.Listen`, которая создает слушателя на заданном порте. В нашем случае, порт задается через строковую константу `gRpcPort`, объявленную в `main.go`.

```go
lis, err := net.Listen("tcp", fmt.Sprintf(":%s", gRpcPort))
if err != nil {
    log.Fatalf("Failed to listen for gRPC: %v", err)
}
```

#### Создание и запуск gRPC сервера
Далее мы создаем новый gRPC-сервер с помощью метода `grpc.NewServer()`. После этого нам необходимо зарегистрировать созданный ранее сервис `LogService`, используя автоматически сгенерированную функцию `RegisterLogServiceServer`. В качестве параметров этой функции передаются созданный сервер `s` и экземпляр структуры `LogServer`, которая отвечает за логику обработки запросов.

```go
s := grpc.NewServer()
logs.RegisterLogServiceServer(s, &LogServer{Models: app.Models})
```

#### Логирование и прослушивание соединений
После регистрации сервиса выводится сообщение в лог о том, что сервер gRPC запущен, а затем начинается прослушивание входящих соединений с использованием метода `Serve`, который принимает слушатель `lis`. Если происходит ошибка при запуске прослушивания, она логируется, и приложение завершает работу.

```go
log.Printf("gRPC Server started on port %s", gRpcPort)
if err := s.Serve(lis); err != nil {
    log.Fatalf("Failed to listen for gRPC: %v", err)
}
```

### Вызов функции прослушивания в main.go
Теперь, когда мы реализовали функцию для прослушивания gRPC-соединений, нам нужно вызвать ее из основного файла `main.go`. Мы запустим эту функцию в отдельной горутине, чтобы она работала параллельно с другими задачами сервиса.

Пример кода в `main.go`:

```go
func main() {
    // Подключение к MongoDB
    mongoClient, err := connectToMongo()
    if err != nil {
        log.Panic(err)
    }
    client = mongoClient

    // Создание конфигурации приложения
    app := Config{
        Models: data.New(client),
    }

    // Запуск прослушивания RPC и gRPC
    go app.rpcListen()
    go app.gRPCListen()

    // Запуск веб-сервера
    log.Println("Starting service on port", webPort)
    srv := &http.Server{
        Addr:    fmt.Sprintf(":%s", webPort),
        Handler: app.routes(),
    }
    err = srv.ListenAndServe()
    if err != nil {
        log.Panic()
    }
}
```

#### Параллельное выполнение gRPC и других задач
Здесь мы запускаем функцию `gRPCListen` в новой горутине с помощью `go app.gRPCListen()`. Это позволяет слушать gRPC-соединения параллельно с выполнением других задач, таких как обработка HTTP-запросов и RPC.

```go
go app.gRPCListen()
```

Таким образом, после запуска приложение сможет принимать как HTTP-запросы, так и gRPC-запросы на разных портах.

### Заключение
На этом этапе мы настроили прослушивание gRPC-соединений в микросервисе Logger. В следующей лекции мы создадим клиент для подключения к этому серверу, чтобы можно было взаимодействовать с ним через gRPC.
