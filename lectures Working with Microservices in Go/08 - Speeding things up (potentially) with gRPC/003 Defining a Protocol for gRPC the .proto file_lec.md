## Определение протокола для gRPC: .proto-файл

### 1. Введение в создание .proto-файла

Теперь, когда все необходимые инструменты для работы с gRPC установлены, нам необходимо создать **файл протокола**. Этот файл будет использоваться для генерации исходного кода на основе описания, которое мы в нём укажем. Инструменты, установленные ранее, будут читать этот файл и генерировать код для наших сервисов.

Чтобы приступить к созданию файла протокола, мы сначала перейдём в папку с сервисом **logger** и создадим новый каталог рядом с папкой **CMD**, который назовём **logs**. Внутри этой папки мы создадим новый файл с именем **logs.proto**. Этот файл будет содержать описание протокола, которое поможет инструментам сгенерировать нужный код.

### 2. Структура и синтаксис .proto-файла

Первым шагом в создании .proto-файла является объявление используемого синтаксиса. Мы используем версию **proto3** и указываем это в первой строке:

```proto
syntax = "proto3";
```

Далее мы объявляем пакет, в котором будет размещён сгенерированный код. Назовём его **logs**:

```proto
package logs;
```

После этого указываем опцию для пакета Go, чтобы инструменты знали, где разместить сгенерированный код. Для этого добавляем следующую строку:

```proto
option go_package = "/logs";
```

### 3. Описание сообщений

В gRPC важно описывать типы данных, которые будут передаваться между клиентом и сервером. Мы начинаем с описания сообщений — это структуры данных, которые содержат информацию для передачи.

Первое сообщение, которое мы описываем, называется **Log**. Оно состоит из двух полей: имени и данных, оба типа — строки. Каждое поле получает своё уникальное позиционное значение:

```proto
message Log {
    string name = 1;
    string data = 2;
}
```

Следующее сообщение — **LogRequest**, которое представляет запрос на запись лога. Оно содержит одно поле **logEntry**, в котором передаётся структура **Log**:

```proto
message LogRequest {
    Log logEntry = 1;
}
```

Третье сообщение — **LogResponse**, которое представляет собой ответ на запрос записи лога. В нём содержится одно строковое поле **result**, которое будет содержать результат выполнения операции:

```proto
message LogResponse {
    string result = 1;
}
```

### 4. Определение сервиса и RPC

После описания сообщений мы переходим к определению самого сервиса, который будет реализован в gRPC. Мы объявляем сервис **LogService** и добавляем в него удалённый вызов процедуры (RPC) — функцию, которая будет обрабатывать запросы.

Функция называется **WriteLog**. Она принимает на вход **LogRequest** и возвращает **LogResponse**. Вызов RPC в .proto-файле выглядит следующим образом:

```proto
service LogService {
    rpc WriteLog(LogRequest) returns (LogResponse);
}
```

`rpc` в данном контексте означает "Remote Procedure Call" (удаленный вызов процедуры). Это метод, который клиент может вызвать на сервере, как если бы это был локальный метод, хотя на самом деле он выполняется на удаленном сервере.

**Другими словами:**

**Remote Procedure Call (RPC)** - это метод, который позволяет программе вызывать функции или процедуры на удаленном сервере, как если бы они были локальными. В gRPC это реализуется с помощью протокола HTTP/2 и Protocol Buffers.

-   **service LogService**: Определяет сервис с именем `LogService`.
-   **rpc WriteLog(LogRequest) returns (LogResponse)**:
    -   **rpc**: Объявляет удаленный вызов процедуры.
    -   **WriteLog**: Имя удаленной процедуры, которую можно вызвать.
    -   **(LogRequest)**: Тип сообщения, который клиент отправляет на сервер при вызове этой процедуры.
    -   **returns (LogResponse)**: Тип сообщения, который сервер возвращает клиенту в ответ на вызов процедуры.

#### Пример

Представьте, что у вас есть клиентская программа, которая хочет записать лог-сообщение на сервере. Клиент вызывает метод `WriteLog` на сервисе `logger-service`. Этот вызов отправляется на сервер, где выполняется соответствующая процедура, и результат возвращается клиенту.

Таким образом, `rpc` в данном контексте указывает, что `WriteLog` — это удаленный метод, который может быть вызван клиентом на сервере через gRPC.

#### Визуализация

```
Клиент                     Сервер
  |                          |
  |--- LogRequest ---------> |
  |                          |
  |<-- LogResponse --------- |
  |                          |
```

Таким образом, этот фрагмент кода определяет сервис `LogService` с одной удаленной процедурой `WriteLog`, которая принимает запрос `LogRequest` и возвращает ответ `LogResponse`.

### 5. Резюме

В итоге, мы определили протокол для взаимодействия с нашим логирующим сервисом через gRPC. Мы описали, какие данные будут передаваться (сообщения **Log**, **LogRequest** и **LogResponse**), а также функцию, которая будет обрабатывать эти данные на сервере (**WriteLog**).

Вот итоговый код нашего **logs.proto** файла:

```proto
syntax = "proto3";

package logs;

option go_package = "/logs";

message Log {
    string name = 1;
    string data = 2;
}

message LogRequest {
    Log logEntry = 1;
}

message LogResponse {
    string result = 1;
}

service LogService {
    rpc WriteLog(LogRequest) returns (LogResponse);
}
```

На следующем шаге мы сгенерируем код для клиента и сервера с помощью созданного протокола.
