## Создания клиента, расположенного в **broker-service**

Продолжим разработку микросервисной архитектуры с использованием gRPC. В рамках этой лекции опишем процесс создания клиента, расположенного в **broker-service**, который будет взаимодействовать с сервисом логирования **logger-service** через gRPC.

### 1. Создание клиента для gRPC:

-   В этой лекции мы продолжаем работу с сервисом логирования и создаем клиента в микросервисе брокера, который будет взаимодействовать с сервисом логирования через gRPC.
-   Первым шагом создается новая директория `logs` в сервисе брокера. В эту директорию копируется файл `logs.proto` из `logger-service`, который предоставляет gRPC-метод `WriteLog`. Это нужно для генерации gRPC-кода на стороне клиента `broker service`, чтобы он знал, как общаться с сервером.

### 2. Генерация исходного кода на основе .proto-файла:

-   Для генерации кода используется команда `protoc`:

```bash
protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative logs.proto
```

Эта команда генерирует код клиента на Go для gRPC-сервиса на основе описания в файле `logs.proto`.

### 3. Подключение зависимостей gRPC:

Для корректной работы gRPC-клиента необходимо подключить пакет gRPC:

```bash
go get google.golang.org/grpc
```

Этот шаг важен для того, чтобы код компилировался и имел все необходимые зависимости для работы с gRPC.

### 4. Создание gRPC клиента

После генерации кода мы можем реализовать логику клиента в Go, для этого создадим обработчик для gRPC-запросов:

-   В файл `handlers.go` создадим новый обработчик `LogViaGRPC` для работы с gRPC-запросами. Этот обработчик будет принимать JSON-запросы от HTTP-клиента, а затем пересылать данные через gRPC к лог-сервису.

**Основные этапы:**

-   Объявляется функция `LogViaGRPC`, которая принимает запросы и обрабатывает их.
-   Внутри создается подключение к gRPC-серверу с использованием метода `grpc.Dial` и передаются параметры для безопасности (в данном случае без шифрования, так как это локальная среда).
-   Создается клиент для взаимодействия с лог-сервисом (`logs.NewLogServiceClient`), и через этот клиент вызывается метод `WriteLog` для записи лога.

**Код обработки gRPC-запроса:**

```go
func (app *Config) LogViaGRPC(w http.ResponseWriter, r *http.Request) {
	// 1. Объявляем переменную для хранения данных, получаемых в запросе
	var requestPayload RequestPayload

	// 2. Читаем и парсим JSON-данные из запроса
	err := app.readJSON(w, r, &requestPayload)
	if err != nil {
		// Если при чтении JSON возникла ошибка, возвращаем ответ с ошибкой
		app.errorJSON(w, err)
		return
	}

	// 3. Устанавливаем соединение с gRPC-сервисом по указанному адресу
	conn, err := grpc.Dial("logger-service:50001", grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithBlock())
	if err != nil {
		// Если при подключении к gRPC возникла ошибка, возвращаем ответ с ошибкой
		app.errorJSON(w, err)
		return
	}
	// 4. Закрываем соединение, когда функция завершится
	defer conn.Close()

	// 5. Создаем клиента для работы с gRPC-сервисом
	c := logs.NewLogServiceClient(conn)

	// 6. Создаем контекст с таймаутом в 1 секунду для ограничения времени выполнения запроса
	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	// 7. Отменяем контекст по завершению выполнения функции
	defer cancel()

	// 8. Отправляем запрос на запись лога с данными, полученными от клиента
	_, err = c.WriteLog(ctx, &logs.LogRequest{
		LogEntry: &logs.Log{
			Name: requestPayload.Log.Name, // Имя лога
			Data: requestPayload.Log.Data, // Данные лога
		},
	})
	if err != nil {
		// Если при отправке запроса на запись лога возникла ошибка, возвращаем ответ с ошибкой
		app.errorJSON(w, err)
		return
	}

	// 9. Создаем ответный payload с информацией об успешном выполнении операции
	var payload jsonResponse
	payload.Error = false
	payload.Message = "logged"

	// 10. Отправляем успешный ответ клиенту
	app.writeJSON(w, http.StatusAccepted, payload)
}
```

**Что происходит на каждом этапе:**

#### 1. Чтение и парсинг JSON-данных из HTTP-запроса.

1.  **_Объявление переменной:_** Когда мы объявляем переменную requestPayload, она получает начальные нулевые значения. Это значит, что она не содержит никаких данных, но уже готова для того, чтобы мы в неё что-то записали.

2.  **_Чтение и парсинг данных:_** Когда мы вызываем функцию `app.readJSON(w, r, &requestPayload)`, она выполняет две основные задачи:

    -   Читает JSON-данные из HTTP-запроса (то, что клиент отправил).
    -   Преобразует (парсит) эти данные в структуру Go, которой и является `requestPayload`.

3.  **_Передача переменной по ссылке:_** Мы передаем `requestPayload` в функцию `app.readJSON` не просто как значение, а по ссылке — вот что значит символ `&` перед `requestPayload`. Это позволяет функции изменять содержимое этой переменной напрямую.

    Таким образом, когда функция читает JSON из запроса и преобразует его в структуру Go, она напрямую записывает полученные данные в переменную requestPayload.

#### 2. Установка gRPC-соединения с сервисом логов.

1. `grpc.Dial("logger-service:50001", ...)`:

    - `grpc.Dial`: Эта функция используется для установления соединения с удалённым gRPC-сервисом. В нашем случае мы пытаемся подключиться к сервису по адресу `"logger-service:50001"`.
    - `"logger-service:50001"`: Это строка, которая указывает, куда мы подключаемся. Здесь `"logger-service"` — это имя сервиса (может быть имя хоста или DNS), а `50001` — это порт, на котором работает данный сервис.

    **_Пример:_** Если бы это был обычный веб-сервер, то строка могла бы выглядеть как `"http://example.com:50001"`. В данном случае это gRPC-сервис на определённом порту.

2. `grpc.WithTransportCredentials(insecure.NewCredentials())`:

    - `grpc.WithTransportCredentials`: Этот параметр указывает, какие именно учётные данные (credentials) использовать для защиты соединения.
    - `insecure.NewCredentials()`: Здесь мы говорим, что не хотим использовать шифрованное соединение, а использовать **небезопасные** (insecure) учетные данные, что означает отсутствие шифрования или проверки подлинности (что на практике не рекомендуется, если это не тестовая среда).

    **_Пример:_** В реальных условиях для безопасности обычно используют TLS-сертификаты, чтобы данные передавались по защищенному каналу. Но здесь мы говорим, что не будем использовать шифрование — это проще для тестирования или в закрытой сети.

3. `grpc.WithBlock()`:

    - Этот параметр указывает, что вызов `grpc.Dial` должен заблокировать выполнение программы, пока соединение с gRPC-сервисом не будет установлено. Без этого параметра программа может продолжить выполняться, не дождавшись установления соединения.
    - По сути, программа приостанавливается, пока не будет успешно установлено соединение, или пока не произойдёт ошибка (например, если сервис недоступен).

    **_Пример_**: Представь, что ты звонишь кому-то по телефону. Если ты используешь `WithBlock()`, ты не продолжишь выполнять другие задачи, пока не дозвонишься (или пока не будет сброса вызова). Если бы ты не использовал `WithBlock()`, ты мог бы заняться чем-то другим, пока ждешь соединения.

4. `conn, err := ...`:

    - `conn`: Переменная, которая будет хранить само соединение с сервисом, если оно установлено успешно.
    - `err`: Переменная, которая будет содержать ошибку, если соединение не удалось установить.

    **_Пример:_** Если соединение удачно, в `conn` будет объект, с которым можно работать для отправки данных на сервер. Если что-то пошло не так, `err` будет содержать описание проблемы (например, сервис недоступен).

    **_Весь процесс:_**

    - Мы пытаемся подключиться к удалённому сервису по адресу `"logger-service:50001"`.
    - Для соединения используем небезопасный (без шифрования) канал.
    - Ждем, пока соединение установится (или возникнет ошибка).
    - Если всё прошло успешно, в `conn` сохраняется объект соединения, который используется дальше для общения с сервисом.

#### 3. Создание клиента для выполнения gRPC-запросов.

Cоздаем gRPC-клиент для взаимодействия с удалённым логирующим сервисом. Давай разберём, как это работает:

1. **`logs.NewLogServiceClient(conn)`**:

    - **`logs`**: Это сгенерированный код клиента на основе gRPC-протокола. Когда ты определяешь сервис в `.proto` файле (файл, который используется для описания gRPC API), для него генерируется клиентская и серверная часть. В данном случае пакет `logs` был создан на основе определений в файле `.proto`.
    - **`NewLogServiceClient`**: Это сгенерированная функция, которая создаёт новый клиент для взаимодействия с сервисом логирования (в данном случае это **LogService**).
        - Эту функцию предоставляет сгенерированный код gRPC-клиента, чтобы можно было вызывать удалённые методы (в данном случае логирование) на сервере через этот клиент.
    - **`conn`**: Это объект соединения, который мы создали ранее с помощью функции `grpc.Dial`. Он необходим для того, чтобы клиент мог отправлять запросы к сервису через установленное соединение.

2. **`c`**: Переменная, в которой хранится созданный клиент. Этот клиент мы затем используем для вызова методов удалённого сервиса (например, для записи лога с помощью метода `WriteLog`).

**_Процесс:_**

1. Ранее мы установили gRPC-соединение с логирующим сервисом (через объект `conn`).
2. Теперь, с помощью этой строки кода, мы создаём клиент `LogServiceClient`, который будет использовать это соединение для отправки запросов к логирующему сервису.
3. Этот клиент хранится в переменной `c`, и мы можем вызывать методы этого клиента для выполнения удалённых процедур (например, передать данные на запись лога).

**_Пример 1:_**

Представь, что ты установил телефонное соединение с колл-центром (это наш объект `conn`). Теперь ты набираешь конкретный номер отдела, который занимается логированием (это функция `NewLogServiceClient`). После этого у тебя появляется возможность общаться с этим отделом и отправлять им данные для логирования (через вызовы методов клиента).

**_Пример 2:_**

Представь, что ты открыл сайт онлайн-магазина (установил соединение с сервером). Теперь ты выбираешь конкретный раздел сайта, например, для отправки отзыва о покупке (логирование). После этого ты можешь отправлять запросы в этот раздел, и сервер их обработает.

**_Итог:_**

-   Эта строка создаёт клиент, который будет взаимодействовать с gRPC-сервисом.
-   Используя этот клиент, мы можем вызывать удалённые методы сервиса (например, записывать логи).

#### 4. Создание контекста с таймаутом для управления временем выполнения запроса.

Создаем контекст с ограничением по времени для выполнения gRPC-запроса. Таким образом, мы будем использовать контекст **`ctx`** для того, чтобы контролировать выполнение gRPC-запроса, чтобы вручную отменить выполнение задачи раньше, чем истечет указанный таймаут (в данном случае 1 секунда).

**_Что делает этот код:_**

-   Этот код создаёт **контекст с таймаутом**, который автоматически завершит выполнение задачи, если она не будет выполнена в течение **одной секунды**.
-   Контекст используется для управления временем выполнения операции, а также для передачи отмены по всей цепочке вызовов (например, если один компонент завершит операцию досрочно, все остальные, использующие этот контекст, также должны завершиться).

**_Пример:_**

Представь, что ты отправляешь запрос на сервер, но не хочешь ждать бесконечно, пока он вернёт ответ. Ты устанавливаешь таймер на одну секунду. Если за это время сервер не ответит, ты отменяешь запрос. Этот "таймер" в данном случае и есть контекст с таймаутом.

**_В gRPC:_**

Когда ты делаешь запрос к удалённому сервису через gRPC, ты не хочешь, чтобы запрос зависал бесконечно, если что-то пошло не так (например, сервис не отвечает). Контекст с таймаутом позволяет автоматически прерывать такие запросы, если они занимают слишком много времени.

**_Итог:_**

-   Этот код создаёт контекст с таймаутом на 1 секунду.
-   Если запрос к сервису не завершится в течение этой секунды, он будет автоматически отменён.
-   Это полезно для управления временем выполнения сетевых запросов и предотвращения зависаний программы.

#### 5. Отправка gRPC-запроса на запись логов.

Отправляем запрос на запись лога через gRPC. Давай разберём это пошагово:

1. **`c.WriteLog`**:

    - **`c`** — это клиент gRPC, который был создан ранее (с помощью вызова `logs.NewLogServiceClient(conn)`). Этот клиент используется для взаимодействия с удалённым лог-сервисом.
    - **`WriteLog`** — это метод клиента, который отправляет запрос на запись лога на удалённый сервер. Этот метод асинхронно вызывает сервис gRPC, ожидая ответа.

2. **`ctx`**:

    - Это контекст с таймаутом, который был создан в предыдущей строке кода. Он ограничивает время выполнения запроса до одной секунды. Если запрос не завершится за это время, он будет отменён.

3. **`&logs.LogRequest`**:

    - Это запрос, который отправляется на сервер. В данном случае, это структура `LogRequest`, которая является частью API gRPC для сервиса логирования. Она содержит данные, которые нужно передать в лог-сервис.
    - В запросе есть поле **`LogEntry`**, которое представляет собой лог-запись.

4. **`LogEntry: &logs.Log`**:

    - **`LogEntry`** — это сама лог-запись, которая содержит информацию, которую мы хотим сохранить. Здесь используется структура `logs.Log`, которая описывает поля лога.
    - В данном случае лог-запись содержит два поля:
        - **`Name`** — имя лога, которое пришло с клиента.
        - **`Data`** — данные лога, также полученные от клиента.
    - Эти поля заполняются значениями из переменной **`requestPayload`**, которая была ранее заполнена JSON-данными из HTTP-запроса клиента.

5. **Проверка ошибки**:

    - После вызова `WriteLog`, программа ожидает ответа от сервера. Если при отправке запроса или получении ответа возникнет ошибка, она будет сохранена в переменной **`err`**.
    - Если **`err != nil`**, это означает, что произошла ошибка, и в таком случае вызывается функция `app.errorJSON(w, err)`, которая отправляет обратно клиенту ответ с ошибкой в формате JSON. После этого выполнение функции завершится с помощью `return`.

    **Что делает этот код:**

    **I.** Он отправляет gRPC-запрос на запись лога на удалённый сервер логирования.

    **II.** Лог-запись содержит два поля: имя лога и данные.

    **III.** Если во время отправки запроса или получения ответа возникает ошибка, она обрабатывается, и клиенту отправляется сообщение об ошибке в JSON-формате.

#### 6. Обработка возможных ошибок и отправка ответа клиенту.

Cоздаём и отправляем ответ клиенту после успешного выполнения операции по записи лога через gRPC. Давай разберём её шаг за шагом:

1. **Создание структуры для ответа:**

    ```go
    var payload jsonResponse
    ```

    - Здесь создаётся переменная `payload` типа `jsonResponse`. Эта структура предназначена для отправки о HTTP-ответа клиенту в формате JSON.
        - В данном случае клиент - это клиенсткая часть приложения (frontend) и сейчас мы для неё являемся серверной частью, обрабатывающей от неё HTTP-запрос.

2. **Заполнение полей `payload`:**

    ```go
    payload.Error = false
    payload.Message = "logged"
    ```

    - Поле **`Error`** указывает, произошла ли ошибка при выполнении операции. В данном случае **`Error = false`**, что означает, что операция завершилась успешно.
    - Поле **`Message`** содержит текстовое сообщение, которое информирует клиента о результатах операции. В этом случае сообщение `"logged"` указывает на то, что запись лога была успешно произведена.

3. **Отправка ответа клиенту:**

    ```go
    app.writeJSON(w, http.StatusAccepted, payload)
    ```

    - Здесь вызывается метод **`app.writeJSON`**, который отвечает за отправку ответа клиенту в формате JSON. Он принимает три параметра:
        - **`w`** — это объект `http.ResponseWriter`, который используется для отправки ответа обратно клиенту.
        - **`http.StatusAccepted`** — это статус ответа HTTP. Код `202` (Status Accepted) означает, что запрос был успешно принят, но его обработка может быть ещё не завершена полностью. Однако в данном случае это указывает на успешную запись лога.
        - **`payload`** — это структура с ответом, которая будет преобразована в JSON и отправлена клиенту.

    **Кратко повторим:**

    **I.** Создаёт структуру для ответа в формате JSON, которая сообщает клиенту, что операция по записи лога завершилась успешно.

    **II.** Устанавливает, что не было ошибок (`Error = false`) и добавляет сообщение `"logged"`.

    **III.** Отправляет этот ответ клиенту с HTTP-статусом `202 Accepted`.

    Таким образом, формирует и отправляет клиенту ответ, подтверждающий, что его лог был успешно записан. В ответе указывается, что ошибок не произошло, и возвращается сообщение `"logged"`. Клиент получает этот ответ в формате JSON, что позволяет ему понять, что операция завершилась успешно.

### 5. Регистрация нового маршрута:

-   Для того чтобы клиенты могли отправлять запросы на этот обработчик, в файле `routes.go` добавляется новый маршрут `/log-grpc`, который привязан к функции `LogViaGRPC`.

```go
mux.Post("/log-grpc", app.LogViaGRPC)
```

### 6. Тестирование:

Следующим шагом будет интеграция этого функционала в фронтенд, добавив кнопку для отправки запросов на сервер через gRPC.

### Ключевые моменты:

-   **gRPC** позволяет эффективно передавать данные между микросервисами, обеспечивая высокую производительность и строго типизированные сообщения благодаря Protocol Buffers.
-   **Создание клиента gRPC** в Go не требует больших усилий, так как большинство кода генерируется автоматически из `.proto` файла с использованием утилиты `protoc`.
-   **Ручная регистрация маршрутов** и работа с контекстом (`context`) помогают управлять временем выполнения запросов и ресурсами, что критично для микросервисной архитектуры.

---

### В этой лекции мы научились:

-   Как сгенерировать gRPC клиентский код из `.proto` файла.
-   Как подключить этот клиент в Go-коде и вызвать удаленные методы.
-   Как установить связь между HTTP-запросами и gRPC вызовами через создание обработчиков в Go.

---

### Заключение:

В этой лекция мы сфокусировались на построении gRPC клиента для взаимодействия между брокером и логер-сервисом. Благодаря автоматической генерации кода и простоте работы с gRPC в Go, процесс интеграции оказывается достаточно прямолинейным. Следующим шагом будет тестирование клиентского кода на практике.
