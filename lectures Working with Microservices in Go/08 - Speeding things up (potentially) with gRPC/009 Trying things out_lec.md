## Тестирование работы системы после обновления

### Введение
В этой лекции мы протестируем обновленный фронтенд и проверим, как работает наше подключение к gRPC-сервису. Мы будем компилировать проект, запускать контейнеры Docker и проверять взаимодействие всех сервисов.

### Шаг 1: Компиляция и запуск Docker-контейнеров
Для начала откроем терминал, перейдем в корневую папку проекта и запустим процесс компиляции всех бинарных файлов, а также сборку и запуск Docker-контейнеров с помощью команды:

```bash
make up_build
```

Во время этого процесса мы увидим, как компилируются наши сервисы, такие как брокер и логгер. Это хороший знак, что все собирается корректно.

Далее, после завершения сборки, запускаем фронтенд командой:

```bash
make start
```

Теперь Docker поднимает все необходимые сервисы. Нужно подождать, пока RabbitMQ полностью запустится. Мы можем проверить состояние сервисов через **Docker Desktop**, зайдя на панель управления и найдя наш сервис брокера. Когда увидим сообщение о готовности RabbitMQ, можно переходить к следующему шагу.

### Шаг 2: Тестирование через веб-интерфейс
Откроем веб-браузер и перейдем по адресу `localhost`. Убедимся, что все сервисы работают корректно. Для этого протестируем каждый из них по очереди.

- **Тест брокера**: нажимаем на кнопку для тестирования брокера, видим успешный результат.
- **Тест логгера**: проверим, работает ли логирование. Все проходит без ошибок.
- **Тест gRPC**: нажимаем на кнопку **Test gRPC log**, которая отправляет запрос через gRPC.

Мы видим, что был зарегистрирован ответ с сервера:

```
Output shows here...
Response from broker service: Hit the broker
Response from broker service: Processed payload via RPC:event
Response from broker service: logged
```

Это подтверждает, что данные были успешно переданы и обработаны через gRPC.

### Шаг 3: Просмотр отправленных и полученных данных
Теперь посмотрим на отправленные и полученные данные.

**Отправленные данные**:

```json
{
    "action": "log",
    "log": {
        "name": "event",
        "data": "Some kind of gRPC data"
    }
}
```

**Полученные данные**:

```json
{
    "error": false,
    "message": "logged"
}
```

Это говорит о том, что запрос успешно выполнился, а сообщение было записано в лог.

### Шаг 4: Проверка базы данных MongoDB
Для дальнейшей проверки откроем **MongoDB Compass**, подключимся к базе данных и проверим коллекцию `logs`. Мы видим, что запись с данными, отправленными через gRPC, успешно сохранена в базе данных:

```json
{
  "_id": {
    "$oid": "66ed35245d8dba563bfe4abb"
  },
  "name": "event",
  "data": "Some kind of gRPC data",
  "created_at": {
    "$date": "2024-09-20T08:41:08.120Z"
  },
  "updated_at": {
    "$date": "2024-09-20T08:41:08.120Z"
  }
}
```

Мы видим, что в базе данных содержится запись с именем события `"event"` и данными `"Some kind of gRPC data"`. Это подтверждает, что gRPC-запросы корректно обрабатываются и логируются в MongoDB.

### Заключение
Тестирование прошло успешно, и система работает, как и ожидалось. Важно отметить, что на данный момент gRPC отлично подходит для связи между микросервисами. Однако, как упоминалось в лекции, в веб-браузерах gRPC пока что не работает стабильно — существуют только экспериментальные браузеры, которые могут использовать gRPC для связи с удалёнными сервисами, но они пока не готовы к повсеместному использованию. 

Тем не менее, для взаимодействия микросервисов на бэкенде gRPC является отличным способом ускорить коммуникации.

--- 

Таким образом, мы успешно протестировали интеграцию gRPC, проверили взаимодействие с брокером, логгером и базой данных MongoDB, и убедились, что всё работает корректно.