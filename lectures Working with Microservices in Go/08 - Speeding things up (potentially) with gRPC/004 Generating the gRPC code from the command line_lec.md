## Генерация gRPC-кода из командной строки

### 1. Установка подсветки синтаксиса для .proto-файлов

Между прошлой лекцией и текущей я установил расширение для Visual Studio Code, которое добавляет подсветку синтаксиса для файлов с расширением **.proto**. Это расширение называется **protobuf support**, и его можно установить для улучшения читаемости .proto-файлов. Это не обязательный шаг, но он может помочь при работе с файлами.

### 2. Подготовка к компиляции .proto-файла

Теперь, когда у нас готов .proto-файл для нашего логирующего сервиса, который будет использовать gRPC, пришло время скомпилировать этот файл в исходный код. Этот процесс выполняется через командную строку. Для этого открываем терминал и переходим в каталог **logs** внутри директории сервиса логирования, где находится наш файл **logs.proto**.

Прежде чем продолжить, нам потребуется установить ещё один инструмент — **Protocol Buffer Compiler** (или просто **protoc**). Это небольшое приложение, которое понадобится для компиляции .proto-файлов. Для установки можно следовать инструкциям с сайта [grpc.io](https://grpc.io/docs/protoc-installation/).

### 3. Установка Protocol Buffer Compiler

На сайте grpc.io представлены инструкции по установке **protoc** для разных операционных систем. Рассмотрим несколько вариантов:

-   **Для Linux**:

    ```bash
    $ apt install -y protobuf-compiler
    $ protoc --version  # Убедитесь, что версия компилятора 3+
    ```

-   **Для macOS**:

    ```bash
    $ brew install protobuf
    $ protoc --version  # Убедитесь, что версия компилятора 3+
    ```

-   **Для Windows**: можно скачать предварительно скомпилированный бинарный файл с сайта.

Загрузите соответствующий архив для своей операционной системы, распакуйте его и найдите файл в папке **bin**, который нужно поместить в директорию, доступную в переменной окружения PATH. Обычно для Go-разработки это папка **go/bin**. Далее убедитесь, что **protoc** доступен в терминале, выполнив команду:

```bash
which protoc
```

Если ваша операционная система выдаёт предупреждение о безопасности, как это может быть на macOS, перейдите в **Системные настройки** → **Безопасность и конфиденциальность**, где можно разрешить запуск программы. После этого повторите команду:

```bash
protoc --version
```

Это подтвердит успешную установку и правильную версию компилятора.

### 4. Генерация кода с помощью protoc

Теперь, когда **protoc** установлен и доступен, мы можем сгенерировать Go-код из нашего .proto-файла. Для этого в терминале, находясь в директории **logs**, выполним следующую команду:

```bash
protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative logs.proto
```

Разберём, что делает эта команда:

-   **protoc** — команда для вызова компилятора Protocol Buffers.
-   **--go_out=.** — указывает, что сгенерированный Go-код нужно поместить в текущую директорию.
-   **--go_opt=paths=source_relative** — указывает, что пути к файлам должны быть относительными к исходному .proto-файлу.
-   **--go-grpc_out=.** — аналогично предыдущему флагу, но для gRPC-кода.
-   **--go-grpc_opt=paths=source_relative** — также указывает на использование относительных путей.
-   **logs.proto** — файл, который нужно скомпилировать.

После выполнения команды в текущей директории будут созданы два файла: **logs_grpc.pb.go** и **logs.pb.go**.

---

### 5. Результат генерации

Эти два файла являются автоматически сгенерированным исходным кодом, который мы никогда не будем редактировать вручную. Например, файл **logs.pb.go** содержит описания сообщений и прочих структур, которые были объявлены в .proto-файле. Он использует библиотеки, такие как **proto reflect** и **proto implementation**.

**ОБРАТИТЕ ВНИМАНИЕ!**

Метод `WriteLog` будет создан в сгенерированном файле `logs_grpc.pb.go` **_автоматически_** на основании описания, которое мы задали в **proto-файле**. Давай рассмотрим, как это происходит и как формируется его логика.

Метод `WriteLog` в сгенерированном файле `logs_grpc.pb.go` был **создан автоматически** на основании описания, которое ты задал в **proto-файле**. Давайте рассмотрим, как это происходит и как формируется его логика.

#### Как это работает:

1. **Proto-файл**:
   В protobuf-файле мы описываем сервис и его методы. Например, наш proto-файл может выглядеть примерно так:

    ```proto
    syntax = "proto3";

    package logs;

    service LogService {
      rpc WriteLog(LogRequest) returns (LogResponse);
    }

    message LogRequest {
      Log logEntry = 1;
    }

    message LogResponse {
      bool success = 1;
      string message = 2;
    }

    message Log {
      string name = 1;
      string data = 2;
    }
    ```

    Здесь мы описали сервис `LogService` с методом `WriteLog`, который принимает сообщение типа `LogRequest` и возвращает `LogResponse`. Это описание является **декларацией** того, как должен работать сервис, но само по себе оно не содержит логики.

2. **Генерация Go-кода**:
   Когда мы запускаем инструмент `protoc` с плагином для Go, он автоматически генерирует gRPC-клиент (когда запускаем на клиенте) и сервер (когда запускаем на сервере) для твоего proto-файла. В частности, он генерирует файл `logs_grpc.pb.go`. В этом файле создаются Go-структуры и интерфейсы, соответствующие proto-описанию.

    В файле `logs_grpc.pb.go` создается интерфейс для сервера и клиентская реализация. Для метода `WriteLog` генерируется код, который будет отправлять и принимать данные через gRPC.

    Вот пример сгенерированного клиентского метода `WriteLog`:

    ```go
    func (c *logServiceClient) WriteLog(ctx context.Context, in *LogRequest, opts ...grpc.CallOption) (*LogResponse, error) {
        out := new(LogResponse)
        err := c.cc.Invoke(ctx, "/logs.LogService/WriteLog", in, out, opts...)
        if err != nil {
            return nil, err
        }
        return out, nil
    }
    ```

    Этот код был сгенерирован автоматически на основании proto-описания и выполняет следующую задачу:

    - Метод `WriteLog` отправляет запрос через gRPC к сервису `LoggService`, вызывая метод `WriteLog` на стороне сервера (`logger-service`).
    - Он принимает аргументы: контекст `ctx`, объект запроса `in` (в данном случае это будет `LogRequest`), и дополнительные опции `opts`.
    - Используется метод `Invoke`, который выполняет gRPC-вызов, и если всё прошло успешно, он возвращает результат в виде `LogResponse`.

3. **Где реализуется логика метода?**

    Логика самого метода **реализуется на стороне сервера**, который мы должны реализовать вручную. В proto-файле мы только **декларируем** структуру данных и интерфейс метода, но логика (например, сохранение логов в базу данных или запись в файл) должна быть прописана отдельно в коде сервера.

    В сгенерированном файле `logs_grpc.pb.go` будет сгенерирован интерфейс для сервера, например:

    ```go
    type LogServiceServer interface {
        WriteLog(context.Context, *LogRequest) (*LogResponse, error)
    }
    ```

    Наша задача — написать **реализацию этого интерфейса** на сервере. То есть, нам нужно реализовать метод `WriteLog` в Go:

    Вот один из вариантов примера реализации интерфейса:

    ```go
    func (s *Server) WriteLog(ctx context.Context, req *logs.LogRequest) (*logs.LogResponse, error) {
        logEntry := req.GetLogEntry()

        // Здесь ты реализуешь логику записи лога
        fmt.Printf("Received log: %s - %s\n", logEntry.Name, logEntry.Data)

        return &logs.LogResponse{
            Success: true,
            Message: "Log has been recorded",
        }, nil
    }
    ```

    Этот код на стороне сервера будет обрабатывать запросы, полученные через gRPC, и выполнять логику, которую ты задашь.

#### Резюме:

-   Метод `WriteLog` в файле `logs_grpc.pb.go` создаётся автоматически на основании proto-описания.
-   Этот метод отправляет запросы на сервер через gRPC, передавая данные, которые были заданы в proto-файле.
-   Логика самого метода `WriteLog` должна быть реализована на **стороне сервера** вручную, где мы определяем, что именно делать с полученными данными.

Таким образом, `proto`-файл служит схемой и декларацией, а реализация логики происходит на стороне сервера, который ты должен написать.

---

Если после создания файлов: `logs_grpc.pb.go` и `logs.pb.go` компилятор будет говорить, что у нас не установлены некоторые необходимые зависимости, не переживайте — мы установим их позже при необходимости.

Основное преимущество генерации кода с помощью **protoc** заключается в том, что один и тот же .proto-файл может быть использован для генерации кода на разных языках программирования, таких как Java или Ruby, при помощи соответствующих команд. Это делает gRPC универсальным инструментом для кросс-языковой разработки.

### 6. Заключение

Теперь мы успешно сгенерировали исходный код на Go из нашего **logs.proto** файла с помощью компилятора **protoc**. В следующей лекции мы продолжим работу и добавим необходимые части для полноценной реализации gRPC-сервиса.

Таким образом, наш процесс выглядит следующим образом: написание **.proto** файла, компиляция его с помощью **protoc**, и дальнейшая интеграция полученного кода в наше приложение.
